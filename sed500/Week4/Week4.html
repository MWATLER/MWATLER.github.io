<h1>Week 4 - High-Level Design, continued</h1>

<h3>Introduction</h3>
<p>This week we continue our study on high-level design. We will look at reports, database design, 
  configuration and data flow. We will also look at UML, structure, behaviour and interaction diagrams.</p>

<h3>Videos</h3>
<table>
  <tr><td>UML:</td><td><a href="https://www.youtube.com/watch?v=UI6lqHOVHic" target="_blank">UML Class Diagram Tutorial</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=zid-MVo7M-E" target="_blank">UML Use Case Diagram Tutorial</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=pCK6prSq8aw" target="_blank">How to Make a UML Sequence Diagram</a></td></tr>
  <tr><td>Software Configuration:</td><td><a href="https://www.youtube.com/watch?v=sMQAtoVZ0zo" target="_blank">How To Use Configuration Data With Desired State Configuration (DSC)</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=1BjmZHRHDv0" target="_blank">XML Schema (XSD) Beginner Tutorial with Demo</a></td></tr>
  <tr><td>Design Patterns:</td><td><a href="https://www.youtube.com/watch?v=FLmBqI3IKMA&t=126s" target="_blank">5 Design Patterns Every Engineer Should Know</a></td></tr>
</table>

<h3>Workshop(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Assignment(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Lecture Material</h3>
<ul>
  <li><a href="Beginning_Software_Engineering_CH5_HIGH-LEVEL_DESIGN.pdf" target="_blank">Beginning Software Engineering Chapter 5</a>, High-Level Design</li>
  <li><a href="Software_Architect's_Handbook_CH5_Designing_Software_Architectures.pdf" target="_blank">Software Architect's Handbook Chapter 5</a>, Designing Software Architecture</li>
</ul>

<h3>Reports</h3>

<p>Almost any nontrivial software project can use some kinds of reports. Business applications might
  include reports that deal with customers (who's buying, who has unpaid bills, where customers
  live), products (inventory, pricing, what's selling well), and users (which employees are selling a lot,
  employee work schedules).</p>

<p>Often customers can give you lists of existing reports that they use now and that they
  want in the new system. They may also think of some new reports that take
  advantage of the new system's features. Adding dozens of new reports throughout the 
  development cycle can be a burden to the developers. You can allow the users to create their own reports. If the
  application uses a SQL database, it's not too hard to buy or build a reporting tool
  that lets users type in queries and see the results. If you use this technique, however, you may need to restrict access to it so the
  users don't see confi dential data. Some SQL statements can also damage the database. For example, the SQL DROP
  TABLE statement can remove a table from the database, destroying all its data.</p>

<h3>Other Outputs</h3>  
<p>In addition to normal reports, you should consider other kinds of outputs that the application might
  create. The application could generate printouts (of reports and other things), web pages, data fi les,
  image fi les, audio (to speakers or to audio fi les), video, output to special devices (such as electronic
  signs), e-mail, or text messages (which is as easy as sending an e-mail to the right address).</p>

<h3>Database</h3>  
<p>Database design is an important part of most applications. The fi rst part of database design is to
  decide what kind of database the program will need. You need to specify whether the application
  will store data in text fi les, XML files, a full-fledged relational database, or something more exotic
  such as a temporal database or object store. Even a program that doesn't use any database still needs
  to store data, perhaps inside the program within arrays, lists, or some other data structure.</p>
<p>If you use a relational database, you can sketch out the tables it contains and their relationships
  during high-level design. Later you can provide more details such as the specifi c fi elds in each table
  and the fi elds that make up the keys linking the tables.</p>

<p>Use good database design practices to ensure that the database is properly normalized. This will be 
  covered in more detail in low-level design.
</p>

<h4>Audit Trails</h4>

<p>An audit trail keeps track of each user who modifi es (and in some applications l views) a specific
  record. Later, management can use the audit trails to see which employee gave a customer a 120-percent 
  discount. Auditing can be as simple as creating a history table that records a user's name,
  a link to the record that was modifi ed, and the date when the change occurred. Some database
  products can even create audit trails for you.</p>

<p>A fancier version might store copies of the original data in each table when its data is modified.
  Later, you can compare the customer's records over time to build an audit trail that re-creates the
exact sequence of changes made for that customer.
</p>

<h4>User Access</h4>

<p>Many applications also need to provide different levels of access to different kinds of data. 
  One way to handle user access is to build a table listing the users and the privileges they should be
given. The program can then disable or remove the buttons and menu items that a particular user
shouldn't be allowed to use.
Many databases can also restrict access to tables or even specifi c columns in tables.
</p>

<h4>Database Maintenance</h4>

<p>A database is like a hall closet: Over time it gets disorganized and full of random junk like string,
  chipped vases, and unmatched socks. Every now and then, you need to reorganize so that you can
  fi nd things effi ciently.
  If you use audit trails and the records require a lot of changes, the database will start to fi ll up with
  old versions of records that have been modifi ed. Even if you don't use audit trails, over time the
  database can become cluttered with outdated records.</p>

<p>In that case, you may want to move some of the older data to long-term storage to keep the main
  database lean and responsive. Depending on the application, you may also need to design a way to
  retrieve the old data if you decide you want it back later.
  You can move the older data into a data warehouse , a secondary database that holds older data for
  analysis. In some applications, you may want to analyze the data and store modifi ed or aggregated
  forms in the warehouse instead of keeping every outdated record.
  You may even want to discard the old data if you're sure you'll never need it again.</p>

<p>Removing old data from a database can help keep it responsive, but a lot of changes to the data
  can make the database's indexes ineffi cient and that can hurt performance. For that reason, you
  may need to periodically re-index key tables or run database tuning software to restore peak
  performance. In large, high-reliability applications, you might need to perform these sorts of tasks
  during off-peak hours such as between midnight and 2 a.m.</p>

<p>Finally, you should design a database backup and recovery scheme. In a low-priority application,
  that might involve copying a data fi le to a DVD every now and then. More typically, it means
  copying the database every night and saving the copy for a few days or a week. For high-reliability
  systems, it may mean buying a special-purpose database that automatically shadows every change
  made to any database record on multiple computers.</p>


<h3>Configuration Data</h3>
<p>You can reduce your workload if you provide configuration screens so that users
  can fine-tune the application without making you write new code. Store parameters to algorithms,
  key amounts, and important durations in the database or in configuration files.
  Make sure that only the right users can modify the parameters. In many applications, only
  managers should change these values.</p>

<h3>Data Flows and States</h3>

<p>Many applications use data that flows among different processes.
  You can think of a piece of data as moving through a sequence of states. The states often
correspond to the processes in the related data flow. Sometimes events can make the data take different paths
through the system. Diagrams help describe the system and the way processes interact with the data, such as 
the diagrams below:<br>
<image src="DataFlowDiagram.jpg" alt="A Data Flow Diagram"></image><br><br>
<image src="DataFlowDiagram2.jpg" alt="Another Data Flow Diagram"></image>
</p>

<h3>Training</h3>
<p>Although it may not be time to start writing training materials, it's never too early to think about
  them. The details of the system will probably change a lot between high-level design and fi nal
  installation, but you can at least think about how you want training to work. You can decide
  whether you want users to attend courses taught by instructors, read printed manuals, watch
  instructional videos, or browse documentation online.
  Trainers may create content that discusses the application's high-level purpose, but you have to fi ll in
  most of the details later as the project develops.</p>

<h3>UML</h3>
<p>The Unified Modeling Language (UML) isn't
  actually a single unified language. Instead it defines several kinds of diagrams that you can use to
  represent different pieces of the system.</p>

<p>UML 2.0 defines 13 diagram types divided into three categories (and one subcategory) as shown in
  the following list:
  <ul>
    <li>Structured Diagram</li>
      <ul>
        <li>Class Diagram</li>
        <li>Composite Structure Diagram</li>
        <li>Component Diagram</li>
        <li>Deployment Diagram </li>
        <li>Object Diagram</li>
        <li>Package Diagram</li>
        <li>Profile Diagram</li>
      </ul>
    <li>Behaviour Diagram</li>
      <ul>
        <li>Activity Diagram</li>
        <li>Use Case Diagram</li>
        <li>State Machine Diagram</li>
      </ul>
    <li>Interaction Diagram</li>
      <ul>
        <li>Sequence Diagram</li>
        <li>Communication Diagram</li>
        <li>Interaction Overview Diagram</li>
        <li>Timing Diagram</li>
      </ul>
  </ul>
</p>

<h4>Structure Diagrams</h4>

<p>A structure diagram describes things that will be in the system you are designing. For example,
  the class diagram (one type of structure diagram) shows relationships among the classes that
  will represent objects in the system such as inventory items, vehicles, expense reports, and coffee
  requisition forms. The following list summarizes UML's structure diagrams:
<ul>
  <li>Class Diagram—Describes the classes that make up the system, their properties and methods,
  and their relationships.</li>
  <li>Object Diagram—Focuses on a particular set of objects and their relationships at a specific time.  </li>
  <li>Component Diagram—Shows how components are combined to form larger parts of the
system.</li>
<li>Composite Structure Diagram—Shows a class's internal structure and the collaborations that
the class allows.</li>
<li>Package Diagram—Describes relationships among the packages that make up a system. For
example, if one package in the system uses features provided by another package, then the
diagram would show the first “importing” the second.</li>
<li>Deployment Diagram—Describes the deployment of artifacts (files, scripts, executables, and
the like) on nodes (hardware devices or execution environments that can execute artifacts).</li>
</ul>
</p>

<p>The most basic of the structure diagrams is the class diagram. In a
  class diagram, a class is represented by a rectangle. The class's name
  goes at the top, is centered, and is in bold. Two sections below the
  name give the class's properties and methods. Symbols are added
  to the left of a class member to show its visibility within the project, as shown below:<br>
<image src="ClassVisibilitySymbols.jpg" alt="Class Visibility Symbols"></image>
</p>

<p>Class diagrams also often show relationships among classes. Lines connect classes that are related
  to each other. A variety of line styles, symbols, arrowheads, and annotations give more information
  about the kinds of relationships. The simplest way to use relationships is to draw an arrow indicating the direction of the relationship
  and label the arrow with the relationship's name. At the line's endpoints, you can add symbols to indicate how many objects are involved in the
  relationship. The following table shows symbols you can add to the ends of a relationship.<br>
  <image src="ClassDiagramMultiplicityIndicators.jpg" alt="Class Diagram Multiplicity Indicators"></image>
</p>

<p>Another important type of class diagram relationship is inheritance. In object-oriented
  programming, one class can inherit the properties and methods of another. In a class diagram, 
  you indicate inheritance by using a hollow arrowhead pointing from the child class
  to the parent class.</p>

<p>Class diagrams for complicated applications can become cluttered and hard to read if you put
  everything in a single huge diagram. To reduce clutter, developers often draw multiple class
  diagrams showing parts of the system. In particular, they often make separate diagrams to show
  inheritance and other relationships. An example of a class diagram is given below:<br>
  <image src="ClassDiagramInheritance.jpg" alt="A Class Diagram with Inheritance"></image>
</p>

<h3>Behavior Diagrams</h3>

<p>UML defines three kinds of basic behavior diagrams : activity diagrams, use case diagrams, and
  state machine diagrams.</p>

<h4>Activity Diagrams</h4>

<p>An activity diagram represents work flows for activities. They include several kinds of symbols
  connected with arrows to show the direction of the work flow. The below table summarizes the symbols:<br>
  <image src="ActivityDiagramSymbols.jpg" alt="Activity Diagram Symbols"></image>
</p>

<p>An activity diagram is a bit like a flowchart showing how work flows. The following is an example 
  of an activity diagram:<br>
  <image src="ActivityDiagram.jpg" alt="An Activity Diagram"></image>
</p>

<h4>Use Case Diagram</h4>

<p>A use case diagram represents a user's interaction with the system. Use case diagrams show stick figures
  representing actors (someone or something that performs a task) connected to tasks represented by ellipses.
  To provide more detail, you can use arrows to join subtasks to tasks. Use the annotation
  &lt;&lt;include&gt;&gt; to mean the task includes the subtask. (It can't take place without the subtask.)
  If a subtask might occur only under some circumstances, connect it to the main task and add the
  annotation &lt;&lt;extend&gt;&gt; . If you like, you can add a note indicating when the extension occurs.
  (Usually both &lt;&lt;include&gt;&gt; and &lt;&lt;extend&gt;&gt; arrows are dashed.)</p>

<p>The below shows a simple online shopping use case diagram:<br>
  <image src="UseCaseDiagram.jpg" alt="A Use Case Diagram"></image>
</p>

<h4>State Machine Diagram</h4>

<p>A state machine diagram shows the states through which an object passes in response to various
  events. States are represented by rounded rectangles. Arrows indicate transitions from one state to
  another. Sometimes annotations on the arrows indicate what causes a transition.
  A black circle represents the starting state and a circled black circle indicates the stopping state.</p>

<p>The below shows a state machine for reading a floating point number. Here the program starts and can 
  read a digit, +, or -. (If it reads any other character, the machine fails
  and the program would need to take some action, such as displaying an error message.) If it reads a
  +, or -, the machine moves to the state “Digit before decimal.” Etc...<br>
  <image src="StateMachine.jpg" alt="A State Machine"></image>
</p>

<h3>Interaction Diagrams</h3>
<p>Interaction diagrams are a subset of activity diagrams. They include sequence diagrams,
  communication diagrams, timing diagrams, and interaction overview diagrams.</p>

<h4>Sequence Diagram</h4>

<p>A sequence diagram shows how objects collaborate in a particular scenario. It represents the
  collaboration as a sequence of messages.
  Objects participating in the collaboration are represented as rectangles or sometimes as stick fi gures
  for actors. They are labeled with a name or class. If the label includes both a name and class, they
  are separated by a colon.
  Below each of the participants is a vertical dashed line called a lifeline . The lifeline basically
  represents the participant sitting there waiting for something to happen.
  An execution specifi cation (called an execution or informally an activation n ) represents a participant
  doing something. In the diagram, these are represented as gray or white rectangles drawn on top of
  the lifeline. You can draw overlapping rectangles to represent overlapping executions.
  Labeled arrows with solid arrowheads represent synchronous messages. Arrows with open
  arrowheads represent asynchronous messages. Finally, dashed arrows with open arrowheads
  represent return messages sent in reply to a calling message.</p>

<p>The below shows a customer, a clerk, and the Movie class interacting to print a ticket for a movie:<br>
  <image src="SequenceDiagram.jpg" alt="A Sequence Diagram"></image>
</p>

<h4>Communication Diagram</h4>

<p>Like a sequence diagram, a communication diagram shows communication among objects during
  some sort of collaboration. The difference is the sequence diagram focuses on the sequence
  of messages, but the communication diagram focuses more on the objects involved in the
  collaboration.
  The diagram uses lines to connect objects that collaborate during an interaction. Labeled arrows
  indicate messages between objects. The messages are numbered that so you can follow the sequence
  of messages.</p>

<p>The following is a communication diagram for buying a movie ticket:<br>
  <image src="CommunicationDiagram.jpg" alt="A Communication Diagram"></image>
</p>

<h4>Timing Diagram</h4>

<p>A timing diagram shows one or more objects' changes in state over time. A timing diagram looks
  a lot like a sequence diagram turned sideways, so time increases from left to right. These diagrams
  can be useful for giving a sense of how long different parts of a scenario will take.
  More elaborate versions of the timing diagram show multiple participants stacked above each other
  with arrows showing how messages pass between the participants.</p>

<h4>Interaction Overview Diagram</h4>

<p>An interaction overview diagram is basically an activity diagram where the nodes can be frames
  that contain other kinds of diagrams. Those nodes can contain sequence, communication, timing,
  and other interaction overview diagrams. This lets you show more detail for nodes that represent
  complicated tasks.</p>
