<h1>Week 3 - High-Level Design</h1>

<h3>Introduction</h3>
<p>This week we start our study on high-level design. We will look at some common architectures along with case studies.</p>

<h3>Videos</h3>
<table>
  <tr><td>High Level Design:</td><td><a href="https://www.youtube.com/watch?v=H703ErIrby8" target="_blank">High Level Design vs Low Level Design</a></td></tr>
  <tr><td>Software Architecture:</td><td><a href="https://www.youtube.com/watch?v=r6TEO6_XsiM" target="_blank">Software Architecture and High Level Design</a></td></tr>
</table>

<h3>Workshop(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Assignment(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Lecture Material</h3>
<ul>
  <li><a href="Beginning_Software_Engineering_CH5_HIGH-LEVEL_DESIGN.pdf" target="_blank">Beginning Software Engineering Chapter 5</a>, High-Level Design</li>
  <li><a href="Software_Architect's_Handbook_CH5_Designing_Software_Architectures.pdf" target="_blank">Software Architect's Handbook Chapter 5</a>, Designing Software Architecture</li>
</ul>

<h3>High-Level Design</h3>

<p>High-level design provides a view of the system at an abstract level. It shows how the major
  pieces of the fi nished application will fi t together and interact with each other.
  A high-level design should also specify assumptions about the environment in which the
  fi nished application will run. For example, it should describe the hardware and software you
  will use to develop the application, and the hardware that will eventually run the program.
  The high-level design does not focus on the details of how the pieces of the application will
  work. Those details can be worked out later during low-level design and implementation.</p>

<p>You can view software development as a process that chops up the system into smaller and smaller
  pieces until the pieces are small enough to implement. Using that viewpoint, high-level design is the
  fi rst step in the chopping up process.
  The goal is to divide the system into chunks that are self-contained enough that you could give them
  to separate teams to implement.</p>
  
<h3>What to Specify</h3>
<p>The stages of a software engineering project often blur together, and that's as true for highlevel
  design as it is for any other part of development. Exactly what you should specify in the high-level 
  design varies somewhat, but some things are constant for most projects.</p>
  
<h4>Security</h4>
<p>The fi rst thing you see when you start most applications is a login screen. That's the fi rst obvious
  sign of the application's security, but it's actually not the fi rst piece. Before you even log in to the
  application, you need to log in to the computer.
  Your high-level design should sketch out all the application's security needs. Those needs may
  include the following:
<ul>
<li>Operating system security—This includes the type of login procedures, password expiration
  policies, and password standards. (Those annoying rules that say your password must
  include at least one letter, one number, one special character like # or %, and three Egyptian
  hieroglyphs.)</li>
<li>Application security—Some applications may rely on the operating system's security and not
  provide their own. Others may use the operating system's security to make the user reenter
  the same username and password. Still others may use a separate application username and
  password. Application security also means providing the right level of access to different
  users. For example, some users might not be allowed access to every part of the system. (I'll
  say more about this in the section “User Access” later in the chapter.)</li>
<li>Data security—You need to make sure your customer's credit card information doesn't fall
  into the hands of Eastern European hackers.</li>
<li>Network security—Even if your application and data are secure, cyber banditos might steal
  your data from the network.</li>
<li>Physical security—Many software engineers overlook physical security. Your application
  won't do much good if the laptop it runs on is stolen from an unlocked office.</li>
</ul>
</p>
  
<h4>Hardware</h4>
<p>You
  can build systems to run on mainframes (yes, they still exist), desktops, laptops, tablets, and phones.
  Mini-computers act sort of as a mini-mainframe that can serve a handful of users. Personal Digital
  Assistants (PDAs) are small computers that are basically miniature tablets.
  Wearable devices include such gadgets as computers strapped to the wearer's wrist (sort of like
  a PDA with a wrist strap and possibly extra keys and buttons), wristbands, bracelets, watches,
  eyeglasses, and headsets.
  Additional hardware that you need to specify might include the following:
<ul>
<li>Printers</li>
<li>Network components (cables, modems, gateways, and routers)</li>
<li>Servers (database servers, web servers, and application servers)</li>
<li>Specialized instruments (scales, microscopes, programmable signs, and GPS units)</li>
<li>Audio and video hardware (webcams, headsets, and VOIP)</li>
</ul>
</p>
    
<h4>User Interface</h4>
<p>During high-level design, you can sketch out the user interface, at least at a high level. For example,
  you can indicate the main methods for navigating through the application.
  Older-style desktop applications use forms with menus that display other forms. Often the user
  can display many forms at the same time and switch between them by clicking with the mouse (or
  touching if the hardware has a touch screen).
  In contrast, newer tablet-style applications tend to use a single window (that typically covers the
  entire tablet, or whatever hardware you're using) and buttons or arrows to navigate. When you click
  a button, a new window appears and fi lls the device. Sometimes a Back button lets you move back
  to the previous window.
  Whichever navigational model you pick, you can specify the forms or windows that the application
  will include. You can then verify that they allow the user to perform the tasks defi ned in the
  requirements. In particular, you should walk through the user stories and use cases and make sure
  you've included all the forms needed to handle them.</p>
    
<h4>Internal Interfaces</h4>
<p>When you chop the program into pieces, you should specify how the pieces will interact. Then the
  teams assigned to the pieces can work separately without needing constant coordination.
  It's important that the high-level design specifi es these internal interactions clearly and
  unambiguously so that the teams can work as independently as possible.</p>
  
<h4>External Interfaces</h4>
<p>Many applications must interact with external systems. In a way, external interfaces are often easier to specify than internal ones because you usually don't
  have control over both ends of the interface. If your application needs to interact with an existing
  system, then that system already has interface requirements that you must meet.
  Conversely, if you want future systems to interface with yours, you can probably specify whatever
  interface makes sense to you. Systems developed later need to meet your requirements.</p>

<h3>Architecture</h3>
<p>An application's architecture describes how its pieces fi t together at a high level. Developers use
  a lot of “standard” types of architectures. Many of these address particular characteristics of the
  problem being solved.</p>
    
<h4>Monolithic</h4>
<p>In a monolithic architecture, a single program does everything. It displays the user interface,
  accesses data, processes customer orders, prints invoices, launches missiles, and does whatever else
  the application needs to do.</p>
    
<p>This architecture has some significant drawbacks. In particular, the pieces of the system are tied
  closely together, so it doesn't give you a lot of flexibility. A monolithic architecture also requires
   that you understand how all the pieces of the system fit
  together from the beginning of the project. If you get any of the details wrong, the tight coupling
  between the pieces of the system makes fi xing them later diffi cult.</p>
    
<p>Monolithic architectures do have some advantages. Because everything is built into a single
  program, there's no need for complicated communication across networks. That means you don't
  need to write and debug communication routines; you don't need to worry about the network going
  down; and you don't need to worry about network security. Monolithic architectures are also useful 
  for small applications where a single programmer or team is working on the code.</p>

<h4>Client/Server</h4>
<p>A client/server architecture separates pieces of the system that need to use a
  particular function (clients) from parts of the system that provide those functions
  (servers). That decouples the client and server pieces of the system so that
  developers can work on them separately.<br>
<image src="clientServer1.jpg" alt="Client Server"></image>
</p>
    
<p>One problem with this design is that multiple
  users cannot use the same data. You can fix
  that problem by moving to a two-tier
  architecture where a client (the user interface)
  is separated from the server (the database).</p>
  
<p>The two-tier architecture makes it easier to support multiple clients
  with the same server, but it ties clients and servers relatively closely
  together. The clients must know what format the server uses, and if
  you change the way the server presents its data, you need to change
  the client to match. That may not always be a big problem, but it can
  mean a lot of extra work, particularly in the beginning of a project
  when the client's and server's needs aren't completely known.<br>
  <image src="clientServer2.jpg" alt="Two-Tier Client Server"></image></p>
    
<p>You can help to increase the separation between the clients and server
  if you introduce another layer between the two to create the three tier
  architecture.
  In a three-tier architecture, the middle tier provides insulation between the clients and server.
  The separation provided by the middle tier lets different teams work on the client and server without
interfering with each other too much.<br>
<image src="clientServer3.jpg" alt="Three-Tier Client Server"></image>
</p>

<p>You can define other multi-tier architectures (or N-tier architectures ) that use more than three tiers
    if that would be helpful. For example, a data tier might store the data, a second tier might calculate
    aggregates and perform other calculations on the data, a third tier might use artificial intelligence
    techniques to make recommendations based on the second tier's data, and a fourth tier would be a
    presentation tier that lets users see the results.</p>
        
<h4>Component-Based</h4>
<p>In component-based software engineering (CBSE), you regard the system as a collection of loosely
  coupled components that provide services for each other. A component-based architecture decouples the pieces of code
  much as a multitier architecture does, but the pieces are all contained within the same executable
  program, so they communicate directly instead of across a network.<br>
  <image src="ComponentBased.jpg" alt="Three-Tier Client Server"></image></p>
    
<h4>Service-Oriented</h4>
<p>A service-oriented architecture (SOA) is similar to a component-based architecture except the pieces
  are implemented as services. A service is a self-contained program that runs on its own and provides
  some kind of service for its clients.
  Sometimes, services are implemented as web services. Those are simply programs that satisfy certain
  standards, so they are easy to invoke over the Internet.</p>
  
<h4>Data-Centric</h4>
<p>Data-centric or database-centric architectures come in a variety of fl avors that all use data in some
  central way. The following list summarizes some typical data-centric designs:
<ul>
<li>Storing data in a relational database system. This is so common that it's easy to think of as a
  simple technique for use in other architectures rather than an architecture of its own.</li>
<li>Using tables instead of hard-wired code to control the application. Some artifi cial intelligence
  applications such as rule-based systems use this approach.</li>
<li>Using stored procedures inside the database to perform calculations and implement business
  logic. This can be a lot like putting a middle tier inside the database.</li>
</ul>
</p>
    
<h4>Event-Driven</h4>
<p>In an event-driven architecture ( EDA ), various parts of the system respond to events as they occur.
  For example, as a customer order for robot parts moves through its life cycle, different pieces of
  the system might respond at different times. When the order is created, a fulfillment module might
  notice and print a list of the desired parts and an address label. When the order has been shipped,
  an invoicing module might notice and print an invoice. When the customer hasn't paid the invoice
  for 30 days, an enforcement module might notice and send RoboCop to investigate.  
</p>

<h4>Rule-Based</h4>
<p>A rule-based architecture uses a collection of rules to decide what to do next. These systems are
  sometimes called expert systems or knowledge-based systems. Rule-based systems work well if you can 
  identify the rules necessary to get the job done. Sometimes,
  you can build good rules even for complicated systems; although that can be a lot of work.
  Rule-based systems don't work well if the problem is poorly defi ned so you can't fi gure out what
  rules to use. They also have trouble handling unexpected situations. Rule-based systems are great 
  for handling common simple scenarios, but when they encounter
  anything unexpected they're quite useless. For that reason, you should always give the user a way to
  handle special situations manually.</p>
    
<h4>Distributed</h4>
  <p>In a distributed architecture , different parts of the application run on different processors and may
    run at the same time. The processors could be on different computers scattered across the network,
    or they could be different cores on a single computer. (Most modern computers have multiple cores
    that can execute code at the same time.)</p>
      
  <p>Service-oriented and multitier architectures are often distributed, with different parts of the system
    running on different computers. Component-oriented architectures may also be distributed, with
    different components running on different cores on the same computer. In general, distributed 
    applications can be extremely confusing and hard to debug.</p>

  <p>Distributed computing can suffer from a race condition . The two processes are racing to see which
    one finishes processing first.
    A distributed architecture can improve performance as long as you don't run afoul of race
    conditions and other potential problems.</p>
    
  <h4>Mix and Match</h4>
  <p>An application doesn't need to stick with a single architecture. Different pieces of the application
    might use different design approaches. For example, you might create a distributed service-oriented
    application. Some of the larger services might use a component-based approach to break their code into
    decoupled pieces. Other services might use a multitier approach to separate their features from the data
    storage layer.</p>
      
<h4>Architecture - A Summary</h4>
<p>Suppose you want to pick an architecture for the ClassyDraw application described
  in Chapter 4 of the text <a href="https://ebookcentral-proquest-com.libaccess.senecacollege.ca/lib/senecac/reader.action?docID=1895174&ppg=1" 
  target="_blank">Beginning Software Engineering</a>. ClassyDraw is a drawing program somewhat similar to MS Paint
  except it lets you select and manipulate drawing objects. One way to do that is to
  think about each of the standard architectures and decide whether it would make
  sense to use while building the program.
<ol>
<li>Monolithic —This is basically the default if none of the more elaborate architectures
  apply. We'll come back to this one later.</li>
<li>Client/server, multitier —ClassyDraw stores drawings in fi les, not a database,
  so client/server and multitier architectures aren't needed. (You could store
  drawings in a database if you wanted to, perhaps for an architectural firm
  or some other use where there would be some benefit. For a simple drawing
  application, it would be overkill.)</li>
  <li>Component-based —You could think of different pieces of the application as
  components providing services to each other. For example, you could think of
  a “rectangle component” that draws a rectangle. For this simple application,
  it's probably just as easy to think of a Rectangle class that draws a rectangle,
  so I'm not going to think of this as a component-based approach.</li>
  <li>Service-oriented —This is even less applicable than the component-based approach.
  Spreading the application across multiple computers connected via web services
  (or some other kind of service) wouldn't help a simple drawing application.</li>
  <li>Data-centric —The user defi nes the drawings, so there's no data around which
  to organize the program. (Although a more specialized program, perhaps a
  drafting program for an architectural fi rm or an aerospace design program,
  might interact with data in a meaningful way.)</li>
  <li>Event-driven —The user interface will be event-driven. For example, the user
  selects a tool and then clicks and drags to create a new shape.</li>
  <li>Rule-based —There are no rules that the user must follow to make a drawing,
  so this program isn't rule-based.</li>
  <li>Distributed —This program doesn't perform extensive calculations, so distributing
  pieces across multiple CPUs or cores probably wouldn't help.</li>
</ol>
</p>
    
<p>Because none of the more exotic architectures applied (such as multitier or serviceoriented),
  this application can have a simple monolithic architecture with an eventdriven
  user interface.</p>
  
<h4></h4>
<p></p>
    
<p></p>
        
<p></p>
      
<h4></h4>
<p></p>
    
<p></p>
  
<h4></h4>
<p></p>
    
<p></p>
        
<p></p>
    