<h1>Week 5 - Low-Level Design</h1>

<h3>Introduction</h3>
<p>High-level design paints an application's structure in broad strokes. It identifi es the system's
  general environment (hardware, operating system, network, and so on) and architecture (such
  as monolithic, client/server, and service-oriented). It identifi es the system's major components
  such as reporting modules, databases, and top-level classes. It should also sketch out how the
  pieces of the system will interact.</p>
<p>Low-level design fi lls in some of the gaps to provide extra detail that's necessary before
  developers can start writing code. It gives more specifi c guidance for how the parts of the
  system will work and how they will work together. It refi nes the defi nitions of the database,
  the major classes, and the internal and external interfaces.</p>
<p>High-level design focuses on what t . Low-level design begins to focus on how.</p>

<h3>Videos</h3>
<table>
  <tr><td>Classes: </td><td><a href="https://www.youtube.com/watch?v=Z-RMbahWcrk" target="_blank">Identifying classes: noun analysis</a></td></tr>
  <tr><td>Inheritance: </td><td><a href="https://www.youtube.com/watch?v=pp_axZFU0OY" target="_blank">Inheritance hierarchies</a></td></tr>
  <tr><td>Composition: </td><td><a href="https://www.youtube.com/watch?v=nnwD5Lwwqdo&t=130s" target="_blank">Composition Vs Inheritance - Why You Should Stop Using Inheritance</a></td></tr>
</table>

<h3>Workshop(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Assignment(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Lecture Material</h3>
<ul>
  <li><a href="../Beginning_Software_Engineering_WholeBook.pdf" target="_blank">Beginning Software Engineering</a> Chapter 6, Low-Level Design</li>
  <li><a href="Software_Architect's_Handbook_CH7_Software_Architecture_Patterns.pdf" target="_blank">Software Architect's Handbook Chapter 7</a>, Software Architecture Patterns</li>
</ul>

<h3>OO Design</h3>

<p>The high-level design should have identifi ed the major types of classes that the application will use.
  Now it's time to refine that design to identify the specific classes that program will need. The new
  classes should include definitions of the properties, methods, and events they will provide for the
  application to use.</p>

<p>A property is something that helps define an object. For example, the Author class
  might have FirstName and LastName properties to identify the specifi c author
  an instance represents.</p>

<p>A method is a piece of code that makes an object do something. The Author class
  might have a Search method that searches an object's WrittenWorks values for a work
  that contains a certain word.</p>
  
  <p>An event is something that occurs to tell the program that something interesting
    has happened. An object raises an event when appropriate to let the program
    take some action. For example, an A uthor object might raise a Birthday event
    to tell the program that today is the author's birthday.</p>
      
<h4>Identifying Classes</h4>

<p>One way to pick classes is to look for nouns in a description of
  the application's features. When you're studying possible classes, think about what sorts of information the class needs
  (properties), what sorts of things it needs to do (methods), and whether it needs to notify the
  program of changing circumstances (events).</p>

<p> Note that the class definitions depend heavily on how you will use the objects. For instance, 
  making only a single instance of a class is a warning sign that perhaps the class isn't necessary.
</p>

<h4>Building Inheritance Hierarchies</h4>

<p>After you define the application's main classes, you need to add more detail to represent variations
  on those classes. You can capture the differences between related classes by deriving a child class from a parent class. 
  Child classes automatically inherit the properties, methods, and events defined by the parent
  class. This is one important way object-oriented programming languages achieve 
  <a href="https://cloudemployee.co.uk/blog/code/the-importance-of-code-reusability-in-software-development" target="_blank">code reuse</a>.
  You write code once in the parent class and any child classes use that same code without you rewriting it.
  Because an instance of a child class also belongs to the parent class, the program should be able to
treat the object as if it were of the parent class if that would be helpful. 
</p>

<p>You can derive multiple classes from a single parent class. Conversely, most object-oriented programming 
  languages do not allow multiple inheritance , so a
  class can have at most a single parent class. Because classes can have at most one parent but any
  number of children, the relationships between classes form a tree-like inheritance hierarchy.
  There are a lot of ways you can modify basic inheritance relationships. For example, a child class
  can add properties, methods, and events (which together are called members ) that are not available
  in the parent class. A child class can also replace a parent class member with a new version.
  In some languages the child class can even define a new version of a member that applies when
  the program refers to an object by using the child class but not when it refers to it with a variable
  that has the parent class's type.</p>

<p>The details of how you define classes, build inheritance hierarchies, and add or modify their
  members depend on the language you use. There are two main ways for building
  inheritance hierarchies: refinement and generalization.</p>

<p><b>Refinement</b> is the process of breaking a parent class into multiple subclasses to capture some
  difference between objects in the class. One danger to refi nement is overrefi nement , which happens when you refi ne a class hierarchy
  unnecessarily, making too many classes that make programming more complicated and confusing.
  People are naturally good at categorizing objects:<br>
<image src="InheritanceHierarchies.jpg" alt="Building Inheritance Hierarchies"></image><br><br>
There are two main problems here. First, the classes might capture data that isn't relevant to the
application. Even if the program cares about certain differences between objects, that doesn't
mean those differences would make a good inheritance hierarchy. The second problem with this hierarchy 
is that the differences between cars could easily be
represented by properties instead of by different classes. The differences identifi ed so far actually
are just different values for the same properties. For example, Chevrolet, Ford, and DeLorean are
all just different values for a Make property. You could eliminate that whole level of the hierarchy by
simply adding a Make property to the Car class. You can avoid these kinds of hierarchy problems if 
you focus on behavioral differences between the
different kinds of objects instead of looking at differences in properties. Figure 6-2 shows a revised inheritance hierarchy.<br>
<image src="BehavioralHierarchy.jpg" alt="Building Inheritance Hierarchies"></image><br><br>
The first section under a class's name lists its
properties (just Acceleration in this example).
A subclass does not repeat items that it inherits
without modification from its parent class. In
this example, the Automatic and Manual classes
inherit the Acceleration property.
The second section below a class's name shows
methods ( Accelerate in this example). The
method is italicized in the Car class to indicate
that it is not implemented there and must be
overridden in the child classes.
</p>

<p>Refinement starts with a single class and creates child classes to represent differences between
  objects. <b>Generalization</b> does the opposite: It starts with several classes and creates a parent for them
  to represent common features. Consider a program that draws objects. It needs classes such as
  Rectangle, Ellipse, Polygon, Text, Line, Star, and Hypotrochoid.
  These classes draw different shapes, but they also have a lot in common. They all let you click their
  object to select it, move the object to the top or bottom of the drawing order, move the object, and
  so forth. Because all those objects share these features, it makes sense to create a parent class that defi nes
  them. The program can build a big array or list to hold all the drawing objects represented by the
  parent class and then use polymorphism to invoke the common methods as necessary.<br>
  <image src="Drawable.jpg" alt="Generalization and the Drawable Parent Class"></image><br><br>
  Just as you can go overboard with refi nement to build an inheritance hierarchy containing
  thousands of car classes, you can also get carried away with generalization.
</p>

<h4>Hierarchy Warning Signs</h4>

<p>The following list gives some questions you can ask yourself when trying to decide if you have an
  effective inheritance hierarchy.
<ul>
  <li>Is it tall and thin? In general, tall, thin inheritance hierarchies are more confusing than shorter
  ones. Tall hierarchies make it hard for developers to remember which class to use under
  different circumstances. How tall an inheritance hierarchy can be depends on your application,
  but if it contains more than three or four levels, you should make sure you really need them all.</li>
  <li>Do you have a huge number of classes? Suppose your car sales application needs to track
  make, model, year, color, engine, wheel size, and motorized cup holders. If you try to use
  classes to represent every possible combination, you'll get a combinatorial explosion and
thousands of classes. If you have more than a dozen or so classes, see if you can replace some
with simple properties.</li>
<li>Does a class have only a single subclass? If so, then you can probably remove it and move
whatever it was trying to represent into the subclass.</li>
<li>If there a class at the bottom of the hierarchy that is never instantiated? If the Car hierarchy
has a HalfTrack class and the program never makes an instance of that class, then you
probably don't need the HalfTrack class.</li>
<li>Do the classes all make common sense? If the Car hierarchy contains a Helicopter class,
there's probably something wrong. Either the class doesn't belong there or you should
rename some classes so things make sense. (Perhaps you need a Vehicle class?)</li>
<li>Do classes represent differences in a property's value rather than in behavior or the presence
of properties? A simple sales program might not need separate classes to represent notebooks
and three-hole punches because they're both simple products that you sell one at a time. You
might want a separate class for more expensive objects like computers because they might
have a Warranty property that notebooks and hole punches probably don't have.</li>
</ul>
</p>

<h4>Object Composition</h4>

<p>Inheritance is one way you can reuse code. A child class inherits all of the code defined by its
  parent class, so you don't need to write it again. Another way to reuse code is object composition, a
  technique that uses existing classes to build more complex classes.</p>
<p>For example, suppose you define a Person class that has FirstName, LastName, Address, and Phone
  properties. Now you want to make a Company class that should include information about a contact
  person.</p>
<p>You could make the Company class inherit from the Person class so it would inherit the FirstName,
  LastName, Address, and Phone properties. That would give you places to store the contact person's
  information, but it doesn't make intuitive sense. A company is not a kind of person (despite certain
  Supreme Court rulings), so Company should not inherit from Person.</p>
<p>A better approach is to give the Company class a new property of type Person called
  ContactPerson. Now the Company class gets the benefit of the code defined by the Person class
  without the illogic and possible confusion of inheriting from Person .</p>
<p>This approach also lets you place more than one Person object inside the Company class. For example,
  if you decide the Company class also needs to store information about a billing contact and a shipping
  contact, you can add more Person objects to the class. You couldn't do that with inheritance.</p>
