<h1>Week 9 - Development, continued</h1>

<h3>Introduction</h3>
<p>This week we look at development in more detail. Specifically, we will look at the SOLID design principles.</p>

<h3>Videos</h3>
<table>
  <tr><td>SOLID Design Principles</td><td><a href="https://www.youtube.com/watch?v=yxf2spbpTSw&t=31s" target="_blank">Software Design - Introduction to SOLID Principles in 8 Minutes</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=EwhlHlsav8E" target="_blank">Solid Principles using C++ Single Responsibility Principle</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=Ryhy7333mqQ" target="_blank">Understanding the Open Closed Principle</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=HbGDobtxzWk" target="_blank">Low Level Design 107 | Liskov Substitution Principle | 2022 | System Design</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=1nSVLoOBCh4" target="_blank">Solid Principles using C++ Interface Segregation Principle</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=_CQuOfIqaGE" target="_blank">Low Level Design 108 | Dependency Inversion Principle | 2022 | System Design</a></td></tr>
</table>

<h3>Workshop(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Assignment(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Lecture Material</h3>
<ul>
  <li><a href="../Beginning_Software_Engineering_WholeBook.pdf" target="_blank">Beginning Software Engineering</a> Chapter 7, Development</li>
  <li><a href="Software_Architect's_Handbook_CH6_Software_Development_Principles_and_Practices.pdf" target="_blank">Software Architect's Handbook Chapter 6</a>, 
  Software Development Principles and Practices</li>
</ul>

<h3>Following SOLID Design Principles</h3>

<p>SOLID is an acronym that represents five separate software design principles:
<ul>
<li>Single Responsibility Principle (SRP)</li>
<li>Open/Closed Principle (OCP)</li>
<li>Liskov Substitution Principle (LSP)</li>
<li>Interface Segregation Principle (ISP)</li>
<li>Dependency Inversion Principle (DIP)</li>
</ul>
Software architects should realize that the principles are
guidelines, and while you should strive to follow them, you may not always be able to
accomplish that fully. Use your judgement as to when, and to what degree, these principles
should be followed.
</p>

<h4>Single Responsibility Principle (SRP)</h4>

<p>The Single Responsibility Principle (SRP) states that each class should have only one
  responsibility, meaning it should do one thing and do that thing well. A responsibility is a
  reason to change, so each class should have only one reason to change.</p>

<p>If a class has multiple responsibilities, there is a likelihood that it is used in a greater
  number of places. When one responsibility is changed, not only do we run a higher risk of
  introducing defects into other responsibilities in the same class, but there is a greater
  number of other classes that might be impacted.</p>

<p>Applying this principle does not necessarily mean, as some posit, that each class should
  only have a single public method. Although it does reduce the size of classes, the goal is to
  have each class have a single responsibility. Fulfilling a single responsibility may require
  multiple public methods.</p>

<p>This principle is related to the SoC principle because, as concerns are separated from each
  other, it facilitates the creation of classes that have a single responsibility. Following the
  DRY principle also helps us to abide by the SRP. By removing duplicate code and placing it
  in a single location so that it can be reused, the classes that need the logic do not have to
  repeat it and therefore do not need to be responsible for it.</p>

<h4>Open/Closed Principle (OCP)</h4>

<p>The Open/Closed Principle (OCP) states that software components, such as classes, should
  be open for extension but closed for modification. When requirements change, the design
  should minimize the amount of changes that need to occur on existing code. We should be
  able to extend a component by adding new code without having to modify existing code
  that already works.</p>

<p>When Dr. Bertrand Meyer first came up with the principle in his book Object Oriented
  Software Construction, it focused on using implementation inheritance as the solution. If new
  functionality is needed, a new subtype is created and the base class and any existing
  subtypes could remain unchanged.</p>

<p>Software engineer Robert C. Martin, popularly known as Uncle Bob, redefined the principle
  in his article The Open-Closed Principle, and later in his book Agile Software Development,
  Principles, Patterns, and Practices, by stressing the importance of abstraction and the use of
  interfaces. Using interfaces, we can change implementations as needed. In this way, we can
  change behavior without having to modify existing code that relies on the interfaces.</p>

<h4>Liskov Substitution Principle (LSP)</h4>

<p>The Liskov Substitution Principle (LSP) is an object-oriented principle that states that
  subtypes must be substitutable for their base types without having to alter the base type. If
  a subtype is inherited from a base class, we should be able to substitute the subclass for that
  base class without any issues. Subtypes extending a base class should do so without
  changing the behavior of the base class. When the LSP is violated, it makes for confusing
  code that is hard to understand.</p>

<p>For a given base class or an interface the base class implements, the subtypes of that base
  class should be usable through the base class or an interface the base class implements. The
  methods and properties of the base class should make sense and work as intended for all of
  the subtypes. If the classes work without an issue and behave as expected, the subtypes are
  substitutable for the base class. When the LSP is violated, this is not the case. Although the
  code may compile, unexpected behavior or runtime errors may be experienced.</p>

<h4>Interface Segregation Principle (ISP)</h4>

<p>The Interface Segregation Principle (ISP) states that clients should not be forced to depend
  on properties and methods that they do not use. When designing software, we prefer
  smaller, more cohesive interfaces. If an interface is too large, we can logically split it up into
  multiple interfaces so that clients can focus on only the properties and methods that are of
  interest to them.</p>
  
<p>When interfaces are too large and attempt to cover too many aspects of functionality, they
  are known as fat interfaces. The ISP is violated when classes are dependent on an interface
  with methods they do not need. Violation of the ISP increases coupling and makes
  maintenance more difficult.</p>
  
<h4>Dependency Inversion Principle (DIP)</h4>

<p>The Dependency Inversion Principle (DIP) is a principle that describes how to handle
  dependencies and write loosely coupled software. In their book Agile Principles, Patterns,
  and Practices in C#, Robert C. Martin and Micah Martin state the principle as follows:<br>
<em>"The high-level modules should not depend on low-level modules. Both should depend on
  abstractions.<br>
  Abstractions should not depend upon details. Details should depend upon abstractions."</em><br>
  For example, let's say that Class A depends on Class B and Class B depends on Class C:<br><br>
<image src="ClassABC.jpg" alt="Class A, B, C"></image><br><br>
In a direct dependency graph, at compile time, Class A references Class B which references
Class C. At runtime, the control flow will go from Class A to Class B to Class C. Class A
and Class B will have to instantiate, or new up, their dependencies. This creates tightly
coupled code that is difficult to maintain and test. Changes to one of the dependencies may
require changes to the classes that use those dependencies.
Another disadvantage of this approach is that the code is not unit-testable because of its
dependencies. We will not be able to create mock objects for dependencies because we are
referencing concrete types rather than abstractions. There is no way to inject the mock
objects so that we can create true unit tests that are not dependent on other classes.
</p>
  
<p>Rather than high-level classes being dependent on lower-level classes, they should depend
  on abstractions through an interface. The interfaces do not depend on their
  implementations. Instead, the implementations depend on the interfaces:<br>
  <image src="ClassIF_ABC.jpg" alt="Class Interface A, B, C"></image><br><br>
  With an inverted dependency graph, at compile time, Class A depends on an abstraction
  (Interface B), which in turn depends on an abstraction (Interface C). Class B and Class C
  implement Interface B and Interface C, respectively.
  At run time, the flow of control goes through the interfaces, and each interface has an
implementation.
The DIP is closely related to the inversion of control principle, with the inversion of control
being applied to dependencies.
</p>

<h4>Inversion of Control (IoC)</h4>

<p>Inversion of Control (IoC) is a design principle in which a software system receives the
  flow of control from reusable code, such as a framework. In traditional procedural
  programming, a software system would call into a reusable library. The IOC principle
  inverts this flow of control by allowing the reusable code to call into the software system.</p>
  
<p>Developers are now so familiar with using a variety of frameworks, and even multiple
  frameworks on a single project, that the principle of IoC is no longer a novel one. Although
  the principle of IoC can be applied to many more things than just dependencies, it has
  become closely related to dependencies for its IOC over them.</p>
  
<p>This is the reason why DI containers were originally, and sometimes still are, referred to as
  IoC containers. DI containers are frameworks that provide DI functionality, and we will
  discuss them shortly.</p>
  
<h4>Dependency Injection (DI)</h4>

<p>Dependency Injection (DI) is a technique that provides dependencies to a class, thereby
  achieving dependency inversion. Dependencies are passed (injected) to a client that needs
  it. There are a number of benefits to using DI in a software application.</p>
  
<p>DI removes hardcoded dependencies and allows them to be changed, at either runtime or
  compile-time. If the implementation of a dependency is determined at runtime rather than
  compile-time, this is known as late binding, or runtime binding. As long as we are
  programming to an interface, the implementation can be swapped out.</p>
<p>DI allows us to write loosely coupled code, making applications easier to maintain, extend,
  and test. As we know, when we need to make a change, loosely coupled code allows us to
  make a change in one part of our application without it affecting other areas of our
  application.</p>
<p>Testability increases in software applications that use DI. Loosely coupled code can be
  tested more easily. Code is written to depend on abstractions and not concrete
  implementations, so dependencies can be mocked with unit testing frameworks. Following
  the LSP, a class is not dependent on a concrete type; it is only dependent on the interface.
  As a result, we can inject mock objects for the dependencies by using the interface and
  writing unit tests.</p>
<p>Parallel development is made easier with DI. Developers can work on different pieces of
  functionality in parallel. Since the implementations are independent of each other, as long
  as the shared interfaces are agreed upon, development can occur at the same time. This is
  particularly beneficial on larger projects with multiple teams. Each team can work
  independently and share interfaces for the functionality that must be integrated.</p>
  
<p><b>Constuctor Injection</b></p>
  
<p>Constructor injection is a technique in which dependencies are passed through a class's
  constructor. This is an excellent way to inject dependencies because the dependencies are
  made explicit. The object cannot be instantiated without its dependencies.
  If a class can be instantiated and its methods called, but the functionality does not work
  properly because one or more dependencies have not been provided, classes are being
  dishonest with their clients. It is a better practice to explicitly require dependencies.</p>
  
<p><b>Property Injection</b></p>

<p>Property injection allows clients to supply a dependency through a public property. If you
  need to provide callers with the ability to provide an instance of a dependency, such as to
  override the default behavior, you can use this injection pattern.</p>
  
<p>The first time the getter is called, if the dependency has not already been supplied, a default
  instance should be provided through lazy initialization. If you want a dependency to only be supplied once through a setter, a check can be
  performed in the setter. This is similar to the singleton pattern.</p>
  
<p>For the lazy initialization, you will need a way to get the default instance. It is not ideal to
  instantiate, or new up, the dependency in the class. However, the default value could be
  provided by another means, such as constructor injection. The property would give you the
  flexibility to provide a different instance at runtime.</p>
  
<p><b>Method injection</b></p>

<p>Method injection is similar to property injection, except a dependency is provided through
  a method rather than a property.</p>
  
<p><b>Service Locator</b></p>

<p>The service locator pattern uses a locator object that encapsulates logic to determine and
  provide an instance of the dependencies that are needed. Although it will vary depending
  on your implementation, a sample call with a service locator might look something like the
  following, resulting in an instance being provided based on the specified interface:<br><br>
  <em>var cache = ServiceLocator.GetInstance&lt;ILogger&gt;();</em><br><br>
  Using the service locator pattern to get dependencies is considered to be an anti-pattern by
  some people because it hides a class's dependencies. As opposed to constructor injection,
  where we can see the dependencies in the public constructor, we would have to look at the
  code to find dependencies being resolved through the service locator. Hiding dependencies
  in this way can lead to runtime or compile-time issues, and make it more difficult to reuse
  the code. This is particularly true if we do not have access to the source code, which might
  be the case if we are using code from a third party. It is preferable to use an explicit method
  to acquire an instance of a dependency.</p>
  
<h4>DI containers</h4>

<p>A Dependency Injection container, sometimes referred as DI container or IoC container, is
  a framework that helps with DI. It creates and injects dependencies for us automatically.</p>
    
<p>It is not necessary to use a DI container in order to take advantage of DI. However, using a
  DI container makes handling dependencies much easier. Unless your application is very
  small in size, leveraging a DI container will eliminate the repetitive grunt work of doing it
  manually. If you were to write some generic code to automate some of it, you are
  essentially creating your own container when you could use an existing framework built
  for that purpose. Dependencies go n levels deep and things can get complicated quickly.</p>
<p>If you do opt to use a DI container, there is a variety of containers available. While there are
  differences among them, they all come with some similar, basic functionality that will
  facilitate DI. Many of them will also come with other advanced features and your needs
  will dictate which features you use. Getting DI containers up and running to use the basic
  features is typically an easy and straightforward process.</p>
