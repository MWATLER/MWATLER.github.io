<h1>Week 11 - Deployment, Documentation and Training</h1>

<h3>Introduction</h3>
<p>.</p>

<h3>Videos</h3>
<table>
  <tr><td></td><td><a href="" target="_blank"></a></td></tr>
  <tr><td></td><td><a href="" target="_blank"></a></td></tr>
  <tr><td></td><td><a href="" target="_blank"></a></td></tr>
</table>

<h3>Workshop(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Assignment(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Lecture Material</h3>
<ul>
  <li><a href="../Beginning_Software_Engineering_WholeBook.pdf" target="_blank">Beginning Software Engineering</a> Chapter 9, Deployment</li>
  <li><a href="https://technicalwriterhq.com/documentation/software-documentation/how-to-write-software-documentation/" target="_blank">How To Write Software Documentation</a> Chapter 9, Deployment</li>
  <li><a href="https://userguiding.com/blog/end-user-training/#conduct" target="_blank">End-User Training</li>
  
</ul>

<h3>Scope</h3>

<p>A project's scope can range from a small tool you wrote for your own use, to in-house business
  software that will be used by hundreds or thousands of users. Some of the largest projects (things
  like operating systems, browsers, and game console games) might have millions of users.
  In addition to the number of users, scope includes the size of the application. It includes the amount
  of data involved, the number of external systems that are affected, and the sheer quantity of code
  (all of which could fail).
  As you can probably guess, larger deployments provide more opportunities for mistakes. Big
  projects have more pieces that can go wrong. They also provide more combinations of little things
  that can add up to big problems.
  For those reasons, small deployments are usually the smoothest. If you write an application for your
  own use and it doesn't work, you've only inconvenienced yourself and you have no one else to blame.
  If you roll out a new version of an operating system to millions of customers and then immediately
  discover you need to send out a security fix, you lose credibility. (Yes, that scenario happens all the time.)</p>

<h3>The Plan</h3>

<p>To start deployment planning, list the steps that you hope to follow. Describe each step in detail as it
  is supposed to work.
  Next, for every step, list the ways that step could fail. Then describe the actions that you will take if
  one of those failures occurs. Describe work-arounds or alternative approaches that you could use.
  After you've worked through all the plan's desired steps and anticipated as many problems as
  possible, write a rollback plan that lets you undo everything you've done. Be sure you can restore
  any other applications that you've updated and any data that you've converted for the new system.
  At some point, the pain of retreat is greater than the pain of moving forward. Some call that the point
of no return . People often underestimate how painful moving forward can be, however, so it's good
to delay the point of no return as much as possible.
</p>

<h3>Cutover</h3>

<p>Cutover is the process of moving users to the new application. There are several ways you can
  manage cutover. For some applications, you can just post the new version on the Internet and let
  users grab it. For other projects, you may be able to e-mail a new version to users, or you may be
  able to just install the new system on users' computers.
  More interesting deployments require that you do a bunch of set up (upgrading operating systems,
  converting data into new formats, and installing coffee machines) before you can move users to the
  new system.
  During the setup time, the users may be unable to do their jobs. To minimize disruption, it's
  important that the whole process go as smoothly as possible. The following sections describe four
  ways you can make life easier for all concerned: staged deployment, gradual cutover, incremental
  deployment, and parallel testing.</p>

<h4>Staged Deployment</h4>

<p>If you can't reduce the impact of catastrophic failures, you can sometimes reduce their likelihood
  by using staged deployment. In staged deployment , you build a staging area , a fully functional
  environment where you can practice deployment until you've worked out all the kinks.
  After you have the installation working smoothly, you can test the new application in an
  environment that's more realistic than the one used by the developers. You can use the staging area
  to find and fix a few final bugs before you infl ict them on the users.
  If you can, use power users to help do the testing. They'll know what problems the other users are
  most likely to encounter. (Users can also break a system in ways no programmer or tester can.)
  Staged testing will also give them a preview of what's coming. Hopefully, they'll like what they see
  and tell the other users how wonderful their future lives will soon become. When you're fairly certain 
  that everything is ready for prime time, you can perform the actual deployment.</p>

<p>You still need a deployment plan in case something unexpected goes wrong. Just because everything
  works flawlessly in the staging environment doesn't mean it will on the users' machines. However,
  staging should have reduced the number of major problems you encounter.</p>

<h4>Gradual Cutover</h4>

<p>In gradual cutover , you install the new application for some users while other users continue
  working with their existing system. You move one user to the new application and thoroughly test it.
  When you're sure everything is working well, you move a second user to the new system. When that
  user is up and running, you install a third user, then a fourth, and so on until everyone is running
  the new application.
</p>

<p>The advantage to this approach is that you don't destroy every user's productivity if something goes
  wrong. The first few guinea pigs may suffer a bit, but the others will continue with business as usual
  until you work out any tangles in the installation procedure. Hopefully, you'll stumble across most
  of the unexpected problems with the first couple of users, and deployment will be effortless for most
  of the others.</p>
<p>One big drawback to this approach is that the system is schizophrenic during deployment.
  Some users are using one system while others are doing something different. Depending on the
  application, that can be hard to manage. You may need to write extra tools to keep the two groups
  logically separated, or you may need to impose temporary rules of operation on the users.</p>

<h4>Incremental Deployment</h4>

<p>In incremental deployment , you release the new system's features to the users gradually. First, you
  install one tool (possibly using staged deployment or gradual cutover to ease the pain). After the
  users are used to the new tool, you give them the next tool.</p>

<p>This method doesn't work well with large monolithic applications because you usually can't install
  just part of such a system. This method often works nicely with iterated development approaches.
  There programmers build one feature at a time and, when a feature is ready, it's released to
  the users.</p>

<h4>Parallel Testing</h4>

<p>Depending on how complicated the new system is, you might want to run in parallel for a while to
  shake the bugs out. For example, if you have enough users, you could have a handful of them start
  using the new system in parallel with the old one. They would use the new system to do their jobs
  just as if the new system were fully deployed.
  Meanwhile another set of users would continue using the old system. The old system is the one that
  actually counts. The new one is used only to see what would happen if it were already installed.
  After a few days, weeks, or however long it takes to give you enough confidence in the new system,
  you start migrating the other users to the new system. You can ease the process by using staged
  deployment and gradual cutover if you like.</p>

<h3>Deployment Tasks</h3>

<p>The tasks you need to perform for a successful deployment depend on the application you're
  installing. The following list itemizes some of the things you might need to deal with for a large deployment:
<ul>
<li>Physical environment —These are physical things that the users need such as cubicles
  or offices, desks, chairs, power, lighting, telephones (possibly including headsets), and
  motivational posters (such as waterfalls, soaring eagles, and cats hanging from clotheslines).
  Plus everything that goes into any work environment such as restrooms, coffee machines, and
  supply closets (where employees can steal staples and rubber cement).</li>
<li>Hardware —This includes network hardware (such as cables, fiber, switches, routers, and
  gateways), printers, scanners, CD or DVD burners, backup hardware, disk farms, database
  hardware, external hard drives, call routers, and, of course, the users' computers.</li>
<li>Documentation —This can include some combination of physical and online documentation.
  It might include training materials, user manuals, help guides, and cheat sheets listing
  common commands.</li>
<li>Training —If the application is complicated or very different from what users currently have
  installed, you may need to train the users. For larger installations, developers may have to
  train the trainers (either professional instructors or power users) who will then train the
  users.</li>
<li>Database —Most nontrivial applications include some sort of database. Depending on the
  database, you may need to install database software on one or more central database servers
  and on the users' computers. You may also want extra hardware and software to provide
  extra data security features such as backups, shadowing, and mirroring.</li>
<li>Other people's software —This is software that you didn't write. It includes systems that
  interact with your application (purchasing systems, web services, file management tools,
  cloud services, and printing and scanning tools) and other software that users need to be
  productive (e-mail, chat, browsers, search engines, trouble-shooting databases, and word
  processors). Plus, of course, the operating system.</li>
<li>Your software —This is the application you've built. It includes the application itself, plus
  any extra tools you've created. It also includes monitoring and testing tools that let you make
  sure the application is working correctly.</li>
</ul>
</p>

<h3>Deployment Mistakes</h3>

<p>The basic steps for successful deployment are (1) make a plan, (2) anticipate mistakes, and (3) work
  through the plan overcoming obstacles as they arise. If something goes wrong and you don't have an
  easy fix, rollback whatever you've done, study the problem, and try again later. You can reduce the
  inconvenience for users by using staged deployment, gradual cutover, incremental deployment, and
  parallel testing.</p>

<p>The following list summarizes some of the easiest ways to torpedo an otherwise viable project:
<ul>
<li>Assume everything will work —This may seem like a rookie's mistake, but many people
  assume their deployment plan will just magically work. Maybe you'll get lucky and that will
  be true, but you should probably assume it won't.</li>
<li>Have no rollback plan —Rolling a deployment back can be a real hassle, but it's usually
  better than living with whatever damage you do during a failed deployment.</li>
<li>Allow insufficient time —If everything goes smoothly, you won't need much time, but when
  something goes wrong, all bets are off. A deployment that should take hours could take
  days or even weeks. Allow extra time for unexpected problems. Then hedge your bets by
  scheduling the end of deployment on a Friday so that you can work into the weekend if the
  plan goes off the rails.</li>
<li>Don't know when to surrender —It's easy to work around one or two small issues that don't
  play out as expected, but how do you know when to stop? If you keep pushing through (or
  around) little issues (and sometimes big ones), eventually all the compromises add up to give
  you a terrible result. (Like a beginning poker player with a pair of threes being gradually
  sucked into a huge pot.) Define conditions under which you'll fold and try again later. For
  example, you might quit after 4 hours or after three things go wrong. Or you might use a
  point system with 1 point for a trivial change, 2 points for a small work-around, and 5 points
  if you can't get something to work. When you get to 5 points, quit for the day.</li>
<li>Skip staging —Staging can be time-consuming and expensive, particularly if you need to
  install new hardware and software. However, for a complicated deployment, staging is
  crucial. It lets you work out all the deployment glitches so that you don't need to completely
  trash the users' computers.</li>
<li>Install lots of updates all at once —It's tempting to install a lot of updates at the same time
  so that you don't need to inconvenience the users repeatedly. Unfortunately, the more things
  you try to do at once, the more likely it is you'll run into problems. Limit the number of
  things you try to deploy all at once. Save the rest for a later deployment.</li>
<li>Use an unstable environment —Have you ever used a computer where the scanning software
  works (sometimes), the print queues seem to get stuck randomly, and your video editing
  software sometimes won't import certain kinds of files? If the tools you use don't work
  together consistently, then you have other problems you should fix before you start a new
  deployment. Sometimes finding the right combination of tools that can work together can be
  challenging. Adding a new application will only make things worse.</li>
<li>Set an early point of no return —If you explicitly set a point of no return, you don't need to
  figure out how to roll back any changes after that point. Unfortunately, you don't always
  know how bad things might get near the end of the deployment. The last installation task
  could be a total disaster that takes you days to figure out. You should set the point of no
  return as late as possible in the deployment schedule so that you can retreat whenever
  necessary. Even better, don't have a point of no return!</li>
</ul>
There's a common theme to these methods for failure. They all assume things will go well. Perhaps
this is more of the unbounded optimism that makes programmer's fail to test their code. You just
wrote the deployment plan and you didn't see anything wrong with it. If you had, you would have
fixed it. The logical conclusion is that everything will work perfectly. That means you don't need a
rollback plan, sufficient time, surrender conditions, staging, and a late point of no return.
Assume you will have problems. If you also assume that some of those problems may be big, you'll
be ready in case you need to cancel the deployment and start over. If you prepare for the worst, the
worst that will happen is you'll be pleasantly surprised when things go well.
</p>
