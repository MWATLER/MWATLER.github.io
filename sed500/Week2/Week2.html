<h1>Week 2 - Scope and Requirements</h1>

<h3>Introduction</h3>
<p>This week we will look at project scope and requirements. We will spend much time looking at requirements in detail, including requirement categories, gathering 
  requirements and refining requirements.</p>

<h3>Videos</h3>
<table>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=NXw0bvvYWYo" target="_blank">What is Project Scope? Project Management in Under 5</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=QDLk2QIuJkg" target="_blank">Project Scope Statement [IN 4 EASY STEPS]</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=FRbY0_KxltY" target="_blank">What is a Requirement? Types of Project Requirements</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=0YITbynM2PM" target="_blank">How to Collect Requirements for a Project (Process Explained)</a></td></tr>
</table>

<h3>Workshop(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Assignment(s)</h3>
<p><a href="" target="_blank"></a></p>

<h3>Lecture Material</h3>
<ul>
  <li><a href="Beginning_Software_Engineering_CH4_REQUIREMENT_GATHERING.pdf" target="_blank">Beginning Software Engineering Chapter 4</a>, Requirements Gathering</li>
  <li><a href="Software_Architect's_Handbook_CH3_Understanding_the_Domain.pdf" target="_blank">Software Architect's Handbook Chapter 3</a>, Understanding the Domain</li>
</ul>

<h3>Project Scope</h3>
<p>The project scope is the total amount of work that needs to be done to complete a project. Defining scope is part of the project planning process and helps 
  project managers determine what the project goals, deliverables, tasks, costs and deadlines are. The project scope is usually defined in a document called a 
  scope statement, while the scope management plan explains how it will be controlled. Let's learn about these important project management documents.</p>
<h4>Project Scope Statement</h4>
  
<p>As mentioned above, the scope statement is the project management document that describes the scope of a project. It usually includes the following elements:
<ul>
<li>Project Goals & Objectives: The project requirements or acceptance criteria.</li>
<li>Project Deliverables: The outcomes of project tasks.</li>
<li>Project Exclusions & Constraints: As a project manager you need to explain what can't be done and why.</li>
<li>Project Assumptions: Some initial assumptions that the project management team has before executing the work.</li>
<li>Project Milestones: These mark important moments in your project life cycle, such as the end of a phase.</li>
<li>Scope Baseline: Your original scope as you planned it. The scope baseline allows you to compare actual results against what it's in your scope statement.</li>
</ul>  
  The scope statement is also a guideline for the project manager. It helps them make decisions about change requests throughout the project life cycle. Change is 
  an inevitable part of any project, no matter how thorough your project plan is, so you want to include the likelihood of change in your scope statement to better 
  manage it later.</p>

<h3>Requirements Defined</h3>

<p>Requirements are the features that your application must provide. At the beginning of the project,
  you gather requirements from the customers to fi gure out what you need to build. Throughout
  development, you use the requirements to guide development and ensure that you're heading in
  the right direction. At the end of the project, you use the requirements to verify that the fi nished
  application actually does what it's supposed to do.</p>

<h4>Clear</h4>
<p>Good requirements are clear, concise, and easy to understand. That means they can't be pumped
  full of management-speak, florid prose, and confusing jargon.
  It is okay to use technical terms and abbreviations if they are defined somewhere or they are common
  knowledge in the project's domain.</p>

<h4>Unambiguous</h4>
<p>If the requirement is
  worded so that you can't tell what it requires, then you can't build a system to satisfy it. Although
  this may seem like an obvious feature of any good requirement, it's sometimes harder to guarantee
  than you might think. As you write requirements, do your best to make them unambiguous. Read them carefully to make
  sure you can't think of any way to interpret them other than the way you intend.</p>

<h4>Consistent</h4>
<p>A project's requirements must be consistent with each other. That means not only that they cannot
  contradict each other, but that they also don't provide so many constraints that the problem is unsolvable.
  Each requirement must also be self-consistent. (In other words, it must be possible to achieve.)</p>

<h4>Prioritized</h4>
<p>When you start working on the project's schedule, it's likely you'll need to cut a few nice-to-haves
  from the design. You might like to include every feature but don't have the time or budget, so
  something's got to go.
  At this point, you need to prioritize the requirements. If you've assigned costs (usually in terms of
  time to implement) and priorities to the requirements, then you can defer the high-cost, low-priority
  requirements until a later release.</p>

<p>The exception occurs when you work on life-critical applications such as nuclear reactor cooling,
  air traffi c control, and space shuttle fl ight software. In those types of applications, the customer
  may have a lot of “must have” requirements that you can't remove without compromising the
  applications' safety.</p>

<b>The Moscow Method</b>
<p><b>MOSCOW</b> is an acronym to help you remember a common system for prioritizing
  application features. The consonants in MOSCOW stand for the following:</p>
<p><b>M—Must</b>. These are required features that must d be included. They are necessary
  for the project to be considered a success.</p>
<p><b>S—Should</b>. These are important features that should be included if possible. If
  there's a work-around and there's no room in the release 1 schedule, these may be
  deferred until release 2.</p>
<p><b>C—Could</b>. These are desirable features that can be omitted if they won't fi t in the
  schedule. They can be pushed back into release 2, but they're not as important as
  the “should” features, so they may not make it into release 2, either.</p>
<p><b>W—Won't</b>. These are completely optional features that the customers have agreed
  will not be included in the current release. They may be included in a future release
  if time permits. (Or they may just be included in the requirements list to make
  a particularly loud and politically connected</p>

<h4>Verifiable</h4>
<p>Requirements must be verifi able. If you can't verify a requirement, how do you know whether you've
  met it? Being verifiable means the requirements must be limited and precisely defi ned. They can't be
  open-ended statements.</p>

<h4>Words to Avoid</h4>
<p>Some words are ambiguous or subjective, and adding them to a requirement can make the whole
  thing fuzzy and imprecise. The following list gives examples of words that may make requirements
  less exact.
  <ul>
<li>Comparatives —Words like faster, better, more, and shinier. How much faster? Defi ne
  “better.” How much more? These need to be quantifi ed.</li>
<li>Imprecise adjectives —Words like fast, robust, user-friendly, effi cient, fl exible, and glorious.
  These are just other forms of the comparatives. They look great in management reports,
  business cases, and marketing material, but they're too imprecise to use in requirements.</li>
<li>Vague commands —Words like minimize, maximize, improve, and optimize. Unless you use
  these in a technical algorithmic sense (for example, if you optimize fl ow through a network),
  these are just fancy ways to say, “Do your best.” Even in an algorithmic sense, these sorts of
  words are often applied to hard problems where exact solutions may not exist. In any case,
  you need to make the goals more concrete. Provide some numbers or other criteria you can
  use to determine whether a requirement has been met.</li>
</ul>
</p>

<h3>Requirement Categories</h3>
<p>In general, requirements tell what an application is supposed to do. Good requirements share certain
  characteristics (they're clear, unambiguous, consistent, prioritized, and verifi able), but there are
  several kinds of requirements that are aimed at different audiences or that focus on different aspects
  of the application.</p>
  
<h4>Audience-Oriented Requirements</h4>
<p>These categories focus on different audiences and the different points of view that each audience
  has. They use a somewhat business-oriented perspective to classify requirements according to the
  people who care the most about them.</p>

<p><b>Business requirements</b> lay out the project's high-level goals. They explain what the customer hopes
  to achieve with the project.
  Notice the word "hopes."" Customers sometimes try to include all their hopes and dreams in the
  business requirements in addition to verifiable objectives. Sometimes, those vague goals are unavoidable 
  in business requirements, but if possible you should
  try to push them into the business case. The business case is a more marketing-style document that
  attempts to justify the project. Those often include graphs and charts showing projected costs,
  demand, sales fi gures, and other values that aren't known exactly in advance.</p>

<p><b>User requirements</b> (which are also called <b>stakeholder requirements</b> by managers who like to use the
  word "stakeholder"), describe how the project will be used by the eventual end users. They often
  include things like sketches of forms, scripts that show the steps users will perform to accomplish
  specifi c tasks, use cases, and prototypes. (The sections “Use Cases” and “Prototypes” later in this
  chapter say more about the last two.)
  Sometimes these requirements are very detailed, spelling out exactly what an application must do
  under different circumstances. Other times they specify what the user needs to accomplish but not
  necessarily how the application must accomplish it. Vague requirements are bad, but flexible 
  requirements let you explore different options before you
  start writing code. To keep requirements as fl exible as possible, try to make the requirements spell
  out the project's needs without mandating a particular approach.</p>

<p><b>Functional requirements</b> are detailed statements of the project's desired capabilities. They're
  similar to the user requirements but they may also include things that the users won't see
  directly. For example, they might describe reports that the application produces, interfaces
  to other applications, and workfl ows that route orders from one user to another during
  processing.
  These are things the application should do.</p>

<p><b>Nonfunctional requirements</b> are statements about the quality of the application's behavior or
  constraints on how it produces a desired result. They specify things such as the application's
  performance, reliability, and security characteristics.</p>

<p><b>Implementation requirements</b> are temporary features that are needed to transition to using the new
  system but that will be later discarded. For example, suppose you're designing an invoice-tracking
  system to replace an existing system. After you fi nish testing the system and are ready to use it full
  time, you need a method to copy any pending invoices from the old database into the new one. That
  method is an implementation requirement. Other implementation requirements include hiring new staff, 
  buying new hardware, preparing training materials, and actually training the users to use the new system.</p>
        
<h4>FURPS+</h4>
<p>FURPS+ is an extension of FURPS to add a few categories specific to software engineering.
  FURPS stands for functionality, usability, reliability, performance, and 
  supportability. FURPS+ adds design constraints, implementation requirements, interface requirements, and 
  physical (hardware) requirements.</p>

<p><b>Functionality</b> —What the application should do. These requirements describe the system's
  general features including what it does, interfaces with other systems, security, and so forth.</p>

<p><b>Usability</b> —What the program should look like. These requirements describe user-oriented
  features such as the application's general appearance, ease of use, navigation methods, and
  responsiveness.</p>

<p><b>Reliability</b> —How reliable the system should be. These requirements indicate such things as
  when the system should be available (12 hours per day from 7:00 a.m to 8:00 p.m.), how
  often it can fail (3 times per year for no more than 1 hour each time), and how accurate the
  system is (80 percent of the service calls must start within their predicted delivery windows).</p>

<p><b>Performance</b> —How effi cient the system should be. These requirements describe such things
  as the application's speed, memory usage, disk usage, and database capacity.</p>

<p><b>Supportability</b> —How easy it is to support the application. These requirements include such
  things as how easy it will be to maintain the application, how easy it is to test the code, and
  how fl exible the application is. (For example, the application might let users set parameters
  to determine how it behaves.)</p>

<p><b>Design constraints</b> —These are constraints on the design that are driven by other factors
  such as the hardware platform, software platform, network characteristics, or database. For
  example, suppose you're building a fi nancial application and you want an extremely reliable
  backup system. In that case, you might require the project to use a shadowed or mirrored
  database that stores every transaction off-site in case the main database crashes.</p>

<p><b>Implementation requirements</b> —These are constraints on the way the software is built. For
  example, you might require developers to meet the ISO 9000 standards. (For more information, see 
  <a href="https://www.iso.org/iso/iso_9000" target="_blank">ISO 9000</a>.</p>

<p><b>Interface requirements</b> —These are constraints on the system's interfaces with other systems.
  They tell what other systems will exchange data with the one you're building. They describe
  things like the kinds of interactions that will take place, when they will occur, and the format
  of the data that will be exchanged.</p>

<p><b>Physical requirements</b> —These are constraints on the hardware and physical devices that the
  system will use. For example, they might require a minimum amount of processing power,
  a maximum amount of electrical power, easy portability (such as a tablet or smartphone),
  touch screens, or environmental features (must work in boiling acid).</p>

<h4>Common Requirements</h4>
<p>The following list summarizes some specific requirements common to many applications:
<ul>
  <li>Screens —What screens are needed?</li>
  <li>Menus —What menus will the screens have?</li>
  <li>Navigation —How will the users navigate through different parts of the system? Will they
click buttons, use menus, or click forward and backward arrows? Or some combination of
those methods?</li>
<li>Work fl ow —How does data (work orders, purchase requests, invoices, and other data) move
through the system?</li>
<li>Login —How is login information stored and validated? What are the password formats
(such as, must require at least one letter and number) and rules (as in, passwords must be
changed monthly)?</li>
<li>User types —Are there different kinds of users such as order entry clerk, shipping clerk,
supervisor, and admin? Do they need different privileges?</li>
<li>Audit tracking and history —Does the system need to keep track of who made changes to the
data? (For example, so you can see who changed a customer to premier status.)</li>
<li>Archiving —Does the system need to archive older data to free up space in the database? Does
it need to copy data into a data warehouse for analysis?</li>
<li>Confi guration —Should the application provide confi guration screens that let the system
administrators change the way the program works? For example, those screens might let
system administrators edit product data, set shipping and handling prices, and set algorithm
parameters. (If you don't build these sorts of screens, you'll have to make those changes for
the customers later.)</li>
</ul>
</p>

<h3>Gathering Requirements</h3>

<p>At this point you know what makes a good requirement (clear, unambiguous, consistent, prioritized,
  and verifi able). You also know how to categorize requirements using audience-oriented, FURPS, or
  FURPS+ methods. But how do you actually pry the requirements out of the customers?
  The following sections describe several techniques you can use to gather and refi ne requirements.</p>

  <h4>Listen to Customers (and Users)</h4>
  <p>Sometimes, customers come equipped with fully developed requirements spelling out exactly what
    the application should do, how it should work, and what it should look like. More often they just
    have a problem that they want solved and a vague notion that a computer might somehow help.</p>
  <p>If the customers insist on a particular feature that you think is unimportant, or if they request
    something that just seems strange, ask them why they want it. Sometimes, the requirement may be a
    random thought that isn't actually important, but sometimes the customers have a good reason that you
    just don't understand.</p>
  
  <h4>Use the Five Ws (and One H)</h4>
  <p>Ask <b>who</b> will be using the software and get to know as much as you can about those people. Find
    out if the users and the customers are the same and learn as much about the users as you can.</p>
    <p>Figure out <b>what</b> the customers need the application to do. Focus on the goals as much as possible
      rather than the customers' ideas about how the solution should work. Sometimes, the customers
      have good ideas about what the application should look like, but you should try to keep your
      options open. Often the project members have a better idea than the customers of the kinds of
      things an application can do, so they may come up with better solutions if they focus on the goals.</p>
    <p>Find out <b>when</b> the application is needed. If the application will be rolled out in phases, find out
      which features are needed when. When you have a good idea about what the project requires, use Gantt charts or other
      techniques to figure out how much time is actually needed. Then compare the customers' desired timeline to 
      the required work schedule. If the two don't match, you need to talk to the customers about deferring some 
      features to a later release.</p>
    <p>Find out <b>where</b> the application will be used. Will it be used on desktop computers in an airconditioned
      offi ce? Or will it be used on phones in a noisy subway?</p>
    <p>Ask <b>why</b> the customers need the application. Find out if there is a real reason to believe a new application 
      will help. Sometimes,
      customers don't have a well thought-out reason for building a new system. They just think it will
      help but don't actually know why.</p>
    <p>Sometimes the customer specifies <b>how</b> a particular application should be built. You shouldn't completely ignore the customers'
      ideas. Sometimes, customers have good ideas, particularly if they relate to existing practices. If
      the users are used to doing something a certain way, you may reduce training time by making the
      application mimic that approach. Be sure to look outside the box for other solutions, but don't
      automatically think that software developers always make better decisions than the customers.</p>

  <h4>Study Users</h4>
  <p>Interviewing customers (and users) can get you a lot of information, but often customers (and
    users) won't tell you everything they do or need to do. They often take for granted details that they
    consider trivial but that may be important to the development team.</p>
  <p>By studying users as they work, you can learn more about what they need to do and how they
    currently do it. Then with your software engineering perspective, you can look for solutions that
    might not occur to the users.</p>

<h3>Refining Requirements</h3>    
<p>After you've talked to the customers and users, and watched the users at work, you should have a
  good understanding about the users' current operations and needs. (If you don't, ask more questions
  and watch the users some more until you do.)
  Next, you need to use what you've learned to develop ideas for solving the user's problems. You need
  to distill the goals (what the customers need to do) into approaches (how the application will do it).</p>

  <h4>Copy Existing Systems</h4>
  <p>If you're building a system to replace an existing system or a manual process, you can often use
    many of the behaviors of the existing system as requirements for the new one.</p>
  <p>This approach has a few advantages. First, it's reasonably straightforward. It doesn't take an
    enormous amount of software engineering experience to dig through an existing application and
    write down what it does. This approach also makes it more likely that the requirements can actually be satisfi ed, at least to
    the extent the current system works. Finally, this approach provides an unambiguous example of what you need to do.</p>
  <p>Even though this approach is straightforward, it has some disadvantages. First, you probably
    wouldn't be building a new version of an existing system unless you planned to make some changes.
    Those changes aren't part of the original system, so there's no guarantee that they're even possible.
    They may also be incompatible with the original system. A second problem with this approach is that users are often reluctant to give up even the tiniest
    features in an existing program.</p>

  <h4>Clairvoyance</h4>
  <p>A lot more often than you might think, one or more people simply look at the project's goals,
    visualize a finished result, and start cranking out requirements. This technique is particularly effective if the project lead has previously built a similar system. In
    that case, the lead already knows more or less what the application needs to do, which things will
    be easy and which will be hard, how much time everything requires, and which kinds of donuts
    motivate the programmers the best.</p>
  
  <h4>Brainstorm</h4>
  <p>Copying an existing application and clairvoyance are good techniques for generating requirements,
    but they share a common disadvantage: They are unlikely to lead you to new innovative solutions that
    might be better than the old ones. To fi nd truly revolutionary solutions, you need to be more creative.
    One way to look for creative solutions is the group creativity exercise known as brainstorming.</p>
  <p>Basically, the gist of the method is to gather as many ideas as possible, not worrying about their
    quality or practicality. After you assemble a large list of possible ideas, you examine them more
    closely to see which deserve further work.
    To allow as many approaches as possible, you should try to get a diverse group of participants.
    In software engineering, that means the group should include customers, users, user interface
    designers, system architects, team leads, programmers, trainers, and anyone else who has an interest
    in the project. Get as many different viewpoints as you can. (Although in practice brainstorming
    becomes less effective if the group becomes larger than 10 or 12 people.)</p>

    
<h3>Recording Requirements</h3> 
<p>After you decide what should be in the requirements, you need to write them down so that everyone
  can read them (and argue about whether they're correct). There are several ways you can record
  requirements so team members can refer to them throughout the project's lifetime.</p>   
  <h4>UML</h4>
  <p>The Unified Modeling Language (UML) lets you specify how parts of the system should work. Despite
    its name, UML isn't a single unified language. Instead it uses several kinds of diagrams to represent
    different pieces of the system. Some of those represent program items such as classes. Others represent
    behaviors, such as the way objects interact with each other and the way data flows through the system.
    A drawback of UML is that it's complicated. UML includes two main categories of diagrams
    that are divided into more than a dozen specifi c types, each with its own complex set of rules.</p>
        
  <h4>User Stories</h4>
  <p>A user story is exactly what you might think: a short story explaining how the system will let the
    user do something. Many developers write stories on index cards to encourage brevity. The scope of each story should
    also be limited so that no story should take too long to implement (no more than a week or two).</p>
  <p>User stories may seem low-tech, but they have some big advantages, not least of which is that people
    are already familiar with them. They are easy to write, easy to understand, and can cover just
    about any situation you can imagine. They can be simple or complex depending on the situation.
    User stories give you a lot of expressiveness and fl exibility without a lot of extra work.</p>
<p>User stories do have some drawbacks. For example, you can easily write stories that are confusing,
  ambiguous, inconsistent with other stories, and unverifiable.</p>
        
  <h4>Use Cases</h4>
  <p>A use case is a description of a series of interactions between actors. The actors can be users or parts
    of the application. Often a use case has a larger scope than a user story. For example, a use case might explain how the
    application will allow a user to examine cardiac ultrasound data for a patient. That user might need
    to use many different screens to examine different kinds of recordings and measurements. Each of
    those subtasks could be described by a user story, but the larger job of examining all the data would
    be too big to describe on a single index card and would take longer to implement than a week or two.</p>
        
    <h4>Prototypes</h4>
    <p>A prototype is a mockup of some or all of the application. The idea is to give the customers a more
      intuitive hands-on feel for what the fi nished application will look like and how it will behave than
      you can get from text descriptions such as user stories and use cases.</p>
    <p>A functional prototype (or working prototype) looks and acts as much like the fi nished application
      will but it's allowed to cheat. It may do something that looks like it works, but it may be incomplete
      and it probably won't use the same methods that the fi nal application will use. It might use less
      efficient algorithms, load data from a text fi le instead of a database, or display random messages
      instead of getting them from another system. It might even use hard-coded fake data.</p>

<p>There are a couple of things you can do with a prototype after it's built. First, you can use it to
  defi ne and refi ne the requirements. You can show it to the customers and, based on their feedback,
  you can modify it to better fi t their needs.
  After you've fine-tuned the prototype so that it represents the customers' requirements as closely as
  possible, you can leave it alone. Alternatively, you can start replacing the prototype code and fake data 
  with production-quality code and real data. Over time, you can evolve the prototype into increasingly functional versions
  until eventually it becomes the fi nished application.</p>

  <h3>Validation and Verification</h3>
<p>After you record the requirements (with whatever methods you prefer), you still need to validate
  them and later verify them. The two terms validation and verification are sometimes used
  interchangeably. Validation means are we doing the right things? Verification means are we doing 
the things right?</p>        

<h3>Changing Requirements</h3>
<p>In many projects, requirements evolve over time. As work proceeds, you may discover that
  something you thought would be easy is hard. Or you may stumble across a technique that lets you
  add a high-value feature with little extra work.
  Often changes are driven by the customers. After they start to see working pieces of the application,
  they may think of other items that they hadn't thought of before.</p>

  <p>Depending on the kind of project, you may accommodate some changes, as long as they don't get out
    of hand. You can help control the number of changes by creating a change control board. Customers
    (and others) can submit change requests to this board (which might actually be a single person) for
    approval. The board decides whether a change should be implemented or deferred to a later release.</p>
