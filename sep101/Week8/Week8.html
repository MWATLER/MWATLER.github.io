<h1>Week 8 - Functions, Arrays and Data Structures</h1>

<h3>Introduction</h3>
<p>This week we will look at functions and data structures. We will look at how we can pass an array of a data structure to a function by value and also by address. 
  We will also look at structures within a structure, as well as file input/output.</p>

<h3>Videos</h3>
<table>
  <tr><td>Lecture Recording</td><td><a href="https://seneca.sharepoint.com/sites/SEP101ProgrammingFundamentals/Shared%20Documents/General/Recordings/View%20Only/SEP101%20Programming%20Fundamentals%20Lecture-20211102_114214-Meeting%20Recording.mp4?web=1" target="_blank">Tuesday, November 2 (mp4)</a></td></tr>
  <tr><td>Functions, Arrays and Structures</td><td><a href="https://www.youtube.com/watch?v=yggto0VVMX0" target="_blank">Passing array of structure into function in c programming</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=tikUAsOVfhY" target="_blank">Array of Structures in C | Passing Structure as a Function Argument in C</a></td></tr>
  <tr><td>File Input/Output</td><td><a href="https://www.youtube.com/watch?v=e-srF6c3TJ8" target="_blank">C Programming Tutorial for Beginners - C File I/O: Create, Open, Write and Close a File</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=01QsW5_fuek" target="_blank">Intro to C Programming - File I/O Program</a></td></tr>
</table>

<h3>Quiz</h3>
<p>.</p>

<h3>Lecture Material</h3>
<ul>
  <li>Chapters 3 and 4 of <a href="https://senecacollege.primo.exlibrisgroup.com/permalink/01SENC_INST/17thfn4/alma997356785103226" target="_blank">C Programming</a> by Rajiv Chopra</li>
  <li><a href="FunctionsArraysStructures.docx" target="_blank">Functions, Arrays and Structures</a></li>
  <li><a href="TextFiles.docx" target="_blank">Text Files</a></li>
</ul>

<h3>Lab(s)</h3>
<ul>
  <li><a href="../Labs/Lab6/Lab6.html" target="_blank">Lab 6</a>.</li>
</ul>

<h3>Assignment(s)</h3>
<p><a href="../Assignments/Assignment1/Assignment1.html" target="_blank">Assignment 1</a>.</p>

<h3>Sample Code</h3>
<p><em>Student Marks</em></p>
<p>We are given a problem where we want to record data for three students at a College. For each student we want to record the name, year of study, marks (up to 6 subjects), number of courses, and average. 
  We want to calculate the average for each student based on the sum of the marks divided by the number of courses. We want to be able to do this by pass-by-value and pass-by-address. At the end,
  we want to calculate the averages for all the students at once.</p>
<p>To resolve the above problem, first we have to find all the nouns/adjectives related to a student and group them in a structure. We see we need the student's name, year of study, an array of marks, 
  the number of subjects, and the student's average. We have to decide the type for each of these variables.</p>
<p>Now we have to find the verbs. We need to calculate a student's average by pass-by-value and pass-by-address. It would make sense to implement these in functions. The first could 
  return the student's average taking in a student structure as argument. The student's average could then be assigned the return value of this function. In the second case where we
  pass a student structure by address, the student's average could be set in the function itself, and the function could return an error status to indicate if everything went well. 
  The third verb is calculating the average for all students. This could be done in a for-next loop where calculate average by address could be called for each student.</p>
<ul>
  <li>The data structure for the student and related function prototypes can be found in <a href="StudentMarks/Student.h" target="_blank">Student.h</a> and the function
    definitions for each student can be found in <a href="StudentMarks/Student.c" target="_blank">Student.c</a>. The main program is
    <a href="StudentMarks/StudentMain.c" target="_blank">StudentMain.c</a>.</li>
</ul>

<p><em>Corporate Information</em></p>
<p>A corporation has 12 employees and would like to record data for each one. For each employee it would like to keep track of the employee's name, position, salary and age. In addition to keeping data 
  on its employees, the corporation also wants to record the average salary, the average age, the maximum salary, and which employee has the maximum salary.</p>
<p>The corporation actually stores all its employee data inside a database. For our purposes, the database will be represented by a file <b>EmployeeDB.txt</b>.</p>
<p>First let us find all nouns/adjectives related to an employee. They are the employee's name, position, salary and age. These could be grouped into a structure since they all 
  relate to one thing - the employee. We need a second structure for the corporation itself. It is said to have 12 employees, so the corporation structure should contain an array of 12 
  employee structures, in addition to variables for the average salary, the average age, the maximum salary, and the employee with the maximum salary (which could be represented by 
  an index into the employee array).</p>
<p>Now let us find the verbs. For the corporation we want to know the average salary, the average age, and the maximum salary and who has the maximum salary. We can have three functions 
  perform each of these three tasks. Since the corporation structure contains average salary, average age, the maximum salary, and the index into the employee array of the maximum 
  salary, we can pass our entire corporation structure by address to each of these function so these functions can update these values.</p>
<p></p>
<ul>
  <li>The data structure for the employee can be found in <a href="CorporateInfo/EmployeeInfo.h" target="_blank">EmployeeInfo.h</a>. The employee database can be found in the 
    file <a href="CorporateInfo/EmployeeDB.txt" target="_blank">EmployeeDB.txt</a>.
     The data structure for corporate information and related function prototypes can be found in <a href="CorporateInfo/CorporateInfo.h" target="_blank">CorporateInfo.h</a>
     and the function definitions for the corporation can be found in <a href="CorporateInfo/CorporateInfo.c" target="_blank">CorporateInfo.c</a>. The main program is
    <a href="CorporateInfo/CorporateInfoMain.c" target="_blank">CorporateInfoMain.c</a>.</li>
</ul>

<p><em>UDP Packet Parser</em></p>
<p>This example is for those of you who want a challenge. Surprisingly, you know enough about C to perform a vital practice in industry, 
  and that is the parsing of a data packet. A data packet consists of control information and user data. To be more precise, a data 
  packet consists of meta-data (data about the data) and the data itself. We will look at a UDP Packet and parse information from it.</p>

<p>The User Datagram Protocol (UDP protocol) is utilized to send data that doesn't necessarily need to be very 
  reliable. The UDP packet is encapsulated in an IP packet which can be transmitted across a network.
  Both UDP and IP have checksums octets which are used to ensure the data has been transmitted without errors.</p>
  
<p>UDP messages are generally faster than TCP provided that the communication link functions properly. UDP is widely
   utilized to send DNS (Domain Name Search) requests, to exchange chat messages, for streaming audio and video data, etc...</p>

<p>The header for the UDP packet contains data about the data (meta-data). After the header comes the data. The data is "Length" packets long, as indicated by OCTETs 5 and 6 below.
  The format for the UDP packet is as follows:<br>
<pre>
  UDP HEADER FORMAT
  
  OCTET 1, 2	Source Port
  OCTET 3, 4	Destination Port
  OCTET 5, 6	Length
  OCTET 7, 8 	Checksum
  OCTET 9, 10...Data
</pre><br>
The following is a UDP packet where the header is in red and the data in green:<br>
<span style="color:red">04 89 00 35 00 2C AB B4</span> <span style="color:green">00 01 01 00 00 01 00 00 00 00 00 00 04 70 6F 70 64 02 69 78 06 6E 65 74 63 6F 6D 03 63 6F 6D 00 00 01 00 01</span><br><br>
This breaks down as follows:
<pre>
  UDP Header  04 89 00 35 00 2C AB B4
  Data        00 01 01 00 00 01 00 00 00 00 00 00 04 70 6F 70 64 02 69 78 06 6E 65 74 63 6F 6D 03 63 6F 6D 00 00 01 00 01
  
  Source Port       04 89 (04*16*16 + 8*16 + 9*1 = 1161)
  Destination Port  00 35 (3*16 + 5 = 53)
  Length            00 2C (2*16 + 12 = 44)
  Checksum          AB B4 (10*16*16*16 + 11*16*16 + 11*16 + 4 = 43956)
  Data              00 01 01 00 00 01 00 00 00 00 00 00 04 70 6F 70 64 02 69 78 06 6E 65 74 63 6F 6D 03 63 6F 6D 00 00 01 00 01
</pre>
</p>
<p>The overall size of a UDP data packet is limited to 65535 bytes, which means there are 8 bytes set aside for the header, and up to 65535-8 bytes set aside for the data.</p>

<p>To solve the problem of a data parser we need to collect the nouns/adjectives into variables and the verbs into functions. We see that source port, destination port, length,
  checksum, and data are all related, so we can put them all in one structure. Let us call the structure UDPPacket. Now to collect the verbs. There is only one action here, and
  that is to parse the data from a data stream and insert into the UDPPacket structure. Since there is only one action here we can put all the code inside the main() function.</p>

<p>Next we have to decide on the types of the variables inside the UDPPacket Structure. The source port, destination port, length, and checksum can all be <b>unsigned integers</b> since 
  they will all represent positive integral numbers, and the data can be a character array (<b>char[]</b>) of length 65535-8:<br>
<pre>
  #define MAX_LEN 65535//The maximum length of a UDP packet is 65535 bytes
  #define HEADER_LEN 8//The length of the packet header
  
  struct UDPPacket {
    //The meta-data, or header
    unsigned int sourcePort;
    unsigned int destPort;
    unsigned int length;
    unsigned int checksum;
    //The data itself
    unsigned char data[MAX_LEN-HEADER_LEN];
  };
</pre><br>
Now comes the hard part, the parsing! Since each octet in the packet is 8 bits long, we can create a pointer of 8 bits to point to each octet in the UDP Packet stream. This pointer 
could be of type <b>unsigned char</b> and can be used to parse the information. It will start with the high byte of the source port, then the low byte, then the high byte of the destination
port, then the low byte, then the high byte of the length, then the low byte, then the high byte of the checksum, then the low byte. It will then have to go through all the data byte by
byte until it has parsed "Length" bytes of data.</p>

<p>In extracting the source port, destination port, length and checksum, the high byte of each has to be multiplied by 256 (16*16) then added to the low byte in order to extract 
  the number correctly.</p>

<p>Code that does all of this can be seen as follows: <a href="UDPPacket/UDPPacket.h" target="_blank">UDPPacket.h</a> and <a href="UDPPacket/UDPPacket.c" target="_blank">UDPPacket.c</a>.</p>
