//openTest.cpp - Demonstrates on_exit()
//
// 07-Feb-19  M. Watler         Created.

#include <fcntl.h>
#include <iostream>
#include <stdlib.h>//on_exit()
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/time.h>

char inFile[] = "/home/miguelwatler/src/Week1/speedTest/LargeOpen.txt";
char outFile[]= "/hoome/miguelwatler/src/Week1/speedTest/LargeOpenCopy.txt";
const int BUF_SIZE=8192;
const long nanosecsPerSecond=1000000000;

using namespace std;

void exit_handler(int ev, void *agr);
void exit_handler2(int ev, void *agr);

int main()
{
    int fdIn, fdOut;
    int openFlags;
    mode_t filePerms;
//  char buf[BUF_SIZE];
    char *buf;
    ssize_t numRead, numWrite;
    double elapsedTime;

    buf=new char[BUF_SIZE];
    on_exit(exit_handler2, buf);
    fdIn = open(inFile, O_RDONLY);
    on_exit(exit_handler, &fdIn);
    if(fdIn==-1) {
       cout << "Error opening " << inFile << endl;
       perror("open");
       return -1;
    }
    openFlags = O_CREAT | O_WRONLY | O_TRUNC;
    filePerms = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;/* rw-rw-rw- */
    fdOut = open(outFile, openFlags, filePerms);
    on_exit(exit_handler, &fdOut);
    if(fdOut==-1) {
       cout << "Error opening " << outFile << endl;
       perror("open");
//     close(fdIn);
       return -1;
    }

    timespec ts1, ts2;
    clock_gettime(CLOCK_REALTIME, &ts1);
    do {
       numRead = read(fdIn, buf, BUF_SIZE);
       numWrite = write(fdOut, buf, numRead);
       if(numWrite!=numRead) {
          cout << "Could not write the whole buffer. numRead: " << numRead << " numWrite: " << numWrite << endl;
       }
    } while (numRead>0);
    clock_gettime(CLOCK_REALTIME, &ts2);
    elapsedTime = (double)(ts2.tv_sec-ts1.tv_sec)*nanosecsPerSecond + (ts2.tv_nsec-ts1.tv_nsec);
    elapsedTime /= nanosecsPerSecond;
    cout << "The elapsed time with open is " << elapsedTime << "seconds" << endl;

    close(fdIn);
    close(fdOut);
    cout << "DONE" << endl;

    return 0;
}

void exit_handler(int ev, void *arg)
{
    int fd=atoi((char *)arg);
    cout<<"exit_handler: ev:"<<ev<<" fd:"<<fd<<endl;
    if(fd>0) {
        cout<<"exit_handler: close(fd)"<<endl;
        close(fd);
    } else {
        cout<<"exit_handler: fd already closed"<<endl;
    }
}

void exit_handler2(int ev, void *arg)
{
    char *buf=(char *)arg;
    cout<<"exit_handler2: ev:"<<ev<<endl;
    if(buf!=NULL) {
        cout<<"exit_handler2: delete buf:"<<buf<<endl;
        delete [] buf;
    } else {
        cout<<"exit_handler2: buf already deallocated"<<endl;
    }
}
