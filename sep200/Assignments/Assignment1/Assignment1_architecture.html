<h2>SEP200 - Assignment 1: Proposed Architecture</h2>

<pre>
For Assignment 1 you really want two versions of the game running. Therefore, you need some kind of CardGameAdapter base class and a 
CardGame class derived from CardGameAdapter. CardGameAdapter is not templated but CardGame is. CardGameAdapter might look something like:

class CardGameAdapter {
public:
    virtual void run() = 0;
    virtual void setMode(int) = 0;
    virtual ~CardGameAdapter() {};
};

CardGame is templated and is derived from CardGameAdapter and can be run through a pointer to CardGameAdapter.

CardGame might have a factory function to generate one of two games. It might be implemented something like:

CardGameAdapter* cardGame() {
    char ldMode;
    std::cout << "Would you like to play in low definition mode? [Y/N] ";
    std::cin >> ldMode;

    CardGameAdapter* cardGame;//MW: Note that CardGameAdapter is not templated but CardGame is
    if (ldMode == 'Y' || ldMode == 'y') {
        cardGame = new CardGame&lt;int&gt;();
        cardGame->setMode(1);//MW: You might need to set a mode flag when you come to run the game.
                             //    It is best to use an enumeration for this, not a magic number as I have here
    }
    else {
        std::cout << "You will be playing in high definition mode." << std::endl;
        cardGame = new CardGame&lt;double&gt;();
        cardGame->setMode(2);//MW: You might need to set a mode flag when you come to run the game.
                             //    It is best to use an enumeration for this, not a magic number as I have here
    }
    return cardGame;
}

Everything is now implemented inside the CardGame class instead of the main function. The main function might simply look like:
int main(void) {
    CardGameAdapter* cGame = cardGame();//MW: runs the templated cardGame through a pointer to a non-templated base class.
                                        //    Polymorphism is beautiful!
    cGame->run();
    delete cGame;
    return 0;
}

Your CardGame class might have variables and functions such as:

const int NUM = 2;

template&lt;typename T&gt;
class CardGame :public CardGameAdapter {
    const int MAX = 21;
    int gameMode;//MW: 1 for low definition, 2 for high definition, this might not be needed.
                 //    If you use gameMode, it is best defined as an enumeration rather than an int
    PlayerBase&lt;T&gt;* player[NUM];
    void setMode(int mode) {//MW: Again, an enumeration is preferred
        gameMode = mode;
    }
public:
    CardGame() {
        player[0] = new PlayerYouth&lt;T&gt;("Noah");
        player[1] = new PlayerAdult&lt;T&gt;("Kenneth");
    }
    ~CardGame() {
        for (PlayerBase&lt;T&gt;* p : player) {
            delete p;
            p = nullptr;
        }
    }
    void run() {
        //MW: the meat of your code goes here...
    }
    ...
};

</pre>