<h1>Week 12 - Smart Pointers, The Preprocessor, Multiple Inheritance and Bitwise Expressions</h1>

<h3>Introduction</h3>
<p>This week we will look at three unrelated topics. The smart pointer ensures that programs are free of memory and resource leaks. 
  Multiple inheritance 
  is a feature of C++ that allows a class to inherit from more than one base class. Bitwise expressions allow operations in C++
  to be performed at the bit level.</p>

<h3>Videos</h3>
<table>
  <tr><td>Smart Pointers</td><td><a href="https://www.youtube.com/watch?v=UOB7-B2MfwA" target="_blank">SMART POINTERS in C++ (std::unique_ptr, std::shared_ptr, std::weak_ptr)</a></td></tr>
  <tr><td>Multiple Inheritance</td><td><a href="https://www.youtube.com/watch?v=JZwBW0nYzsk" target="_blank">C++ Multiple Inheritance Explained</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=3XUXSiC-hPE" target="_blank">Multiple Inheritance in C++ with Ambiguity & Resolution</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=ejTzn_sxv-0" target="_blank">Virtual Base Class In C++ || Multipath Inheritance In C++</a></td></tr>
  <tr><td>Bitwise Expressions</td><td><a href="https://www.youtube.com/watch?v=qTFUnp_KwHg" target="_blank">C++ Bitwise AND and OR</a></td></tr>
</table>

<h3>Quiz</h3>
<p>.</p>

<h3>Lecture Material</h3>
<ul>
  <li>Chapters 11, 12, 21 and 34 of <a href="https://senecacollege.primo.exlibrisgroup.com/permalink/01SENC_INST/iq0dqm/alma997259304203226" target="_blank">The C++ Programming Language</a></li>
  <li>Chapters 2, 4, 12 and 18 of <a href="https://senecacollege.primo.exlibrisgroup.com/permalink/01SENC_INST/1g8f6u9/cdi_safari_books_9780133053043" target="_blank">C++ Primer</a></li>
  <li><a href="SmartPointers.docx" target="_blank">Smart Pointers</a></li>
  <li><a href="MultipleInheritance.docx" target="_blank">Multiple Inheritance</a></li>
  <li><a href="BitwiseExpressions.docx" target="_blank">Bitwise Expressions</a></li>
</ul>

<h3>Lab(s)</h3>
<ul>
  <li><a href="../Labs/Lab9/Lab9.html" target="_blank">Lab 9</a>.</li>
  <li><a href="../Labs/Lab10/Lab10.html" target="_blank">Lab 10</a>.</li>
</ul>

<h3>Assignment(s)</h3>
<ul>
<li><a href="../Assignments/Assignment2/Assignment2.html" target="_blank">Assignment 2</a>.</li>
</ul>

<h3>Sample Code</h3>

<p><em>Smart Pointers</em></p>
<p>A custom smart pointer has been built to demonstrate the internal workings of a smart pointer. The code for a custom smart 
  pointer can be found at:<br>
  <a href="SmartPtr/Title.h" target="_blank">Title.h</a>,
  <a href="SmartPtr/SmartPtr.h" target="_blank">SmartPtr.h</a> and
  <a href="SmartPtr/SmartPtr.cpp" target="_blank">SmartPtr.cpp</a>.<br>
  Code that makes use of C++'s smart pointer <b>unique_ptr</b> to prevent memory leaks can be seen at:<br>
  <a href="SmartPtr2/Title.h" target="_blank">Title.h</a> and
  <a href="SmartPtr2/UniquePtr.cpp" target="_blank">UniquePtr.cpp</a>.<br>
  Code that demonstrates the use of C++'s smart pointer <b>shared_ptr</b> can be found at:<br>
  <a href="SharedPtr/Title.h" target="_blank">Title.h</a> and
  <a href="SharedPtr/SharedPtr.cpp" target="_blank">SharedPtr.cpp</a>.
</p>

<p><em>The Stooge Factory</em></p>

<p>Back in week 5 we looked at the Stooge factory as a demonstration of the factory design pattern. This time we will 
  implement the Stooge factory using the <b>unique_ptr</b>. The Stooge factory creates a set of 
  related objects through a static make_stooge() function. The program is based on the popular comedy "The Three Stooges".
  The factory can create three stooges: Larry, Curly and Moe. They are tied together through a common base class. 
  StoogeMain.cpp allows you to create whichever stooge you wish, up to three of them:<br>
  <a href="StoogeFactory/Stooge.h" target="_blank">Stooge.h</a>,
  <a href="StoogeFactory/Stooge.cpp" target="_blank">Stooge.cpp</a>,
  <a href="StoogeFactory/Curly.h" target="_blank">Curly.h</a>,
  <a href="StoogeFactory/Larry.h" target="_blank">Larry.h</a>,
  <a href="StoogeFactory/Moe.h" target="_blank">Moe.h</a> and
  <a href="StoogeFactory/StoogeMain.cpp" target="_blank">StoogeMain.cpp</a>.
</p>

<p><em>A Database</em></p>

<p>Back in week 3 we looked at a Database which was created and used via the Singleton design pattern. This time we will implement 
  the Singleton with a <b>shared_ptr</b>. The Singleton design pattern to ensure there is only one instance of the database class:<br>
  <a href="SingletonDataBase/Data.txt" target="_blank">Data.txt</a>,
  <a href="SingletonDataBase/Database.h" target="_blank">Database.h</a>,
  <a href="SingletonDataBase/Database.cpp" target="_blank">Database.cpp</a> and
  <a href="SingletonDataBase/DatabaseMain.cpp" target="_blank">DatabaseMain.cpp</a>.
</p>
<p><em>Multiple Inheritance</em></p>
<p>When a class inherits from two or more base classes, ambiguities can result. One way of resolving ambiguities is in the class itself, where 
  it specifies which base class should perform which function. Another way is by making a common base class virtual. Code that demonstrates 
  the resolution of ambiguities can be seen at:<br>
  <a href="VirtualInheritance/Name.h" target="_blank">Name.h</a>,
  <a href="VirtualInheritance/Name.cpp" target="_blank">Name.cpp</a>,
  <a href="VirtualInheritance/NCube.h" target="_blank">NCube.h</a>,
  <a href="VirtualInheritance/NCube.cpp" target="_blank">NCube.cpp</a>,
  <a href="VirtualInheritance/NLitCube.h" target="_blank">NLitCube.h</a>,
  <a href="VirtualInheritance/NLitCube.cpp" target="_blank">NLitCube.cpp</a>,
  <a href="VirtualInheritance/NLitObj.h" target="_blank">NLitObj.h</a>,
  <a href="VirtualInheritance/NLitObj.cpp" target="_blank">NLitObj.cpp</a> and
  <a href="VirtualInheritance/VirtualInheritance.cpp" target="_blank">VirtualInheritance.cpp</a>.
</p>

<p><em>Bitwise Expressions</em></p>
<p>Flags are often used to qualify a certain operations. Files, for instance, have flags to indicate whether the file is read-only, write-only, read-write, to 
  indicate permissions etc... It is a waste of space to store each piece of information inside of a standard data type such as int. Rather, since these 
  flags represent binary states, they could be stored inside specific bits of one flag. For instance, the following document shows how to set and unset 
  flags for a file: <a href="SetUnsetBit/SetUnsetBit.docx" target="_blank">SetUnsetBit.docx</a>.<br>
  The following code follows the document in the setting and unsetting of bits for a files operation class:<br>
  <a href="SetUnsetBit/Sample.txt" target="_blank">Sample.txt</a> and 
  <a href="SetUnsetBit/FileOperations.h" target="_blank">FileOperations.h</a> and 
  <a href="SetUnsetBit/SetUnsetBit.cpp" target="_blank">SetUnsetBit.cpp</a>.
</p>
