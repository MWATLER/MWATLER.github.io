<h1>Week 9 - The Standard Template Library</h1>

<h3>Introduction</h3>
<p>For the next two weeks we are going to look at the Standard Template Library (STL).</p>

<p>The Standard Template Library (STL) is a software library for the C++ programming language that influenced many parts
   of the C++ Standard Library. It provides four components called algorithms, containers, functions, and iterators.
   The STL provides a set of common classes for C++, such as containers and associative arrays, that can be used with any
   built-in type and with any user-defined type that supports some elementary operations (such as copying and assignment). 
   STL algorithms are independent of containers, which significantly reduces the complexity of the library. The STL achieves 
   its results through the use of templates. This approach provides compile-time polymorphism that is often more efficient 
   than traditional run-time polymorphism. Modern C++ compilers are tuned to minimize abstraction penalties arising from heavy 
   use of the STL.</p>

<h3>Videos</h3>
<table>
  <tr><td>The Standard Template Library</td><td><a href="https://www.youtube.com/watch?v=ltBdTiRgSaw" target="_blank">Introduction of STL #1: Overview</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=gxZJ5JNuWMY" target="_blank">Introduction of STL #2: Sequence Containers</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=6iyzPed7FrM" target="_blank">Introduction of STL #3: Associative Containers</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=NNLvY9O7ufU" target="_blank">Introduction of STL #4: Unordered Containers</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=vO2AlrBf5rQ" target="_blank">Introduction of STL #5: Iterators and Algorithms</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=shqvSkk8r0M" target="_blank">Introduction of STL #6: Functors</a></td></tr>
</table>

<h3>Quiz</h3>
<p>.</p>

<h3>Lecture Material</h3>
<ul>
  <li>Chapters 30 to 33  of <a href="https://senecacollege.primo.exlibrisgroup.com/permalink/01SENC_INST/iq0dqm/alma997259304203226" target="_blank">The C++ Programming Language</a></li>
  <li>Chapters 9 to 11 of <a href="https://senecacollege.primo.exlibrisgroup.com/permalink/01SENC_INST/1g8f6u9/cdi_safari_books_9780133053043" target="_blank">C++ Primer</a></li>
  <li><a href="https://cs.smu.ca/~porter/csc/ref/stl/containers_summary.html" target="_blank">STL Container and Container Adaptor Classes: A Summary</a></li>
  <li><a href="https://www.cplusplus.com/reference/stl/" target="_blank">Standard Containers</a></li>
  <li><a href="StandardTemplateLibrary.docx" target="_blank">The Standard Template Library</a></li>
  <li><a href="ContainersIterators.docx" target="_blank">Containers and Iterators</a></li>
  <li><a href="NOTES.rtf" target="_blank">Rough Lecture Notes</a></li>
</ul>

<h3>Lab(s)</h3>
<ul>
  <li><a href="../Labs/Lab6/Lab6.html" target="_blank">Lab 6</a>.</li>
  <li><a href="../Labs/Lab7/Lab7.html" target="_blank">Lab 7</a>.</li>
</ul>

<h3>Assignment(s)</h3>
<p><a href="../Assignments/Assignment1/Assignment1.html" target="_blank">Assignment 1</a>.</p>

<h3>Sample Code</h3>

<p>This week we will look at sample code from container adaptors (stack, queue), sequence containers (deque, vector) as well as associative containers (map).</p>

<p><em>Stack</em></p>
<p>An example of a container adapter is the <b>stack</b>. A practical application of a <b>stack</b> is when a function is called. All parameters are put on the <b>stack</b>, 
  and popped off once the function has been exited. The following code shows a simple implementation of a <b>stack</b>:<br>
<a href="Stack/Stack.cpp" target="_blank">Stack.cpp</a>.</p>

<p><em>Queues</em></p>
<p>A <b>queue</b> is another example of a container adapter. A practical application of a <b>queue</b> is in threaded applications (parallel programming). One thread 
  receives and pushes data on to the <b>queue</b> while another thread pops the data off the <b>queue</b> for processing. This allows the receive and process functions 
  to be split into two parts. The following are two simple examples of a <b>queue</b>:<br>
<a href="Queue/Queue.cpp" target="_blank">Queue.cpp</a> and <a href="Queue2/Queue2.cpp" target="_blank">Queue2.cpp</a>.</p>

<p><em>Deque</em></p>
<p>A <b>deque</b> is an example of a sequence container. It acts as a queue but allows operations on both sides of the queue. Since the <b>deque</b> is a sequence 
  container, one can use an iterator on it. A simple example of a <b>deque</b> with an iterator is shown in the following:<br>
<a href="Deque/Deque.cpp" target="_blank">Deque.cpp</a>.</p>

<p><em>Employee Info</em></p>
<p>Another example of a sequence container is the <b>vector</b>. A <b>vector</b> is very useful in a situation where you have an array of elements, but you 
  do not know the size of the array at runtime, or the array grows or shrinks as the program is run. A vector is a useful alternative to dynamic memory allocation. 
  Since it is a sequence container one can use an iterator with it. An example with a <b>vector</b> is the following code that stores and uses a <b>vector</b> of
  employee information:<br>
<a href="EmployeeInfoSTL/EmployeeInfoSTL.h" target="_blank">EmployeeInfoSTL.h</a>, 
<a href="EmployeeInfoSTL/EmployeeInfoSTL.cpp" target="_blank">EmployeeInfoSTL.cpp</a> and
 <a href="EmployeeInfoSTL/EmployeeInfoSTLMain.cpp" target="_blank">EmployeeInfoSTLMain.cpp</a>.</p>

<p><em>Map of Words</em></p>
<p>An example of an associative container is a <b>map</b>. A practical application of a <b>map</b> is a database. A <b>map</b> is based on key-value pairs and 
  these pairs are sorted internally into a binary tree. This allows for quick searching and sorting. For standard types, the sorting is done internally. For 
  non-standard type, the programmer has to provide the sorting methodology. 
  See <a href="../Labs/Lab7/Customer.h" target="_blank">Customer.h</a> and <a href="../Labs/Lab7/Customer.cpp" target="_blank">Customer.cpp</a> 
  from <a href="../Labs/Lab7/Lab7.html" target="_blank">Lab 7</a> as an example of sorting with a non-standard type.<br>
  The following three examples show some of the features of <b>map</b> through a map of words. As you can see from the example it is possible to 
  iterate through this map of words:<br>
<a href="MapOfWords/MapOfWords.cpp" target="_blank">MapOfWords.cpp</a>, <a href="MapOfWords/MapOfWords2.cpp" target="_blank">MapOfWords2.cpp</a> and 
<a href="MapOfWords/MapOfWords3.cpp" target="_blank">MapOfWords3.cpp</a>.</p>

<p><em>Big Map</em></p>
<p>An example that demonstrate the fast searching ability of a database based on STL's map() can be seen in the following code. Here a database of 
  4 million elements is built. The search is very quick because STL's map is based on the binary tree:<br>
  <a href="BigMap/BigMap.cpp" target="_blank">BigMap.cpp</a>
</p>

<p><em>Toolbox Revisited</em></p>
<p>In week 8 we looked at sample code that demonstrated aggregation of different types which are related through a base class. We used an array 
  of pointers to the base class. This week we are going to do the same, but in one example we will use a 
  <a href="http://cplusplus.com/reference/vector/vector/" target="_blank">vector</a> of pointers to the base class, and in another 
  example we are going to use a <a href="http://cplusplus.com/reference/list/list/" target="_blank">list</a> 
  of pointers to the base class. In all three examples the types are <b>Hammer</b> and <b>Screwdriver</b>. They are both tools derived from a 
  <b>ToolIf</b> interface class.</p>
  <ul>
  <li>In example one, we use a vector of pointers to <b>ToolIf</b>:<br>
  <a href="ToolboxVector/ToolIf.h" target="_blank">ToolIf.h</a>,
  <a href="ToolboxVector/ToolIf.cpp" target="_blank">ToolIf.cpp</a>,
  <a href="ToolboxVector/Hammer.h" target="_blank">Hammer.h</a>,
  <a href="ToolboxVector/Screwdriver.h" target="_blank">Screwdriver.h</a>,
  <a href="ToolboxVector/Toolbox.h" target="_blank">Toolbox.h</a> and
  <a href="ToolboxVector/ToolMain.cpp" target="_blank">ToolMain.cpp</a>.<br>
  A sample run is shown in <a href="ToolboxVector/SampleRun.txt" target="_blank">SampleRun.txt</a>. Notice that when using a vector, the only difference between 
  this code and that of week 8, is that we push_back onto the vector. Other than that, the vector in this example can be treated the same as an array.
</li>
<li>In example two, we use a list of pointers to <b>ToolIf</b>:<br>
  <a href="ToolboxList/ToolIf.h" target="_blank">ToolIf.h</a>,
  <a href="ToolboxList/ToolIf.cpp" target="_blank">ToolIf.cpp</a>,
  <a href="ToolboxList/Hammer.h" target="_blank">Hammer.h</a>,
  <a href="ToolboxList/Screwdriver.h" target="_blank">Screwdriver.h</a>,
  <a href="ToolboxList/Toolbox.h" target="_blank">Toolbox.h</a> and
  <a href="ToolboxList/ToolMain.cpp" target="_blank">ToolMain.cpp</a>.<br>
  A sample run is shown in <a href="ToolboxList/SampleRun.txt" target="_blank">SampleRun.txt</a>. Notice that when using a list, we could push to or pop from 
  the front of the list or push to or pop from the back of the list, because std::list in C++ uses a doubly linked list. 
  <a href="http://cplusplus.com/reference/forward_list/forward_list/" target="_blank">forward_list</a> uses a singly linked 
  list and only allows pushing to and popping from the front of the list.<br>
  This example includes the ability to remove an item from the list. With lists it is easy to insert or remove items from any position in the list. The 
  RemoveTool() function found in the sample code removes a tool using the tool's name as the key. It iterates through the list until the names match.
  The iterator is then used to remove the item from the list.
</ul>
