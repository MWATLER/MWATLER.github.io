<h1>Week 10 - Functions (Advanced), Exceptions and Linked Lists</h1>

<h3>Introduction</h3>
<p>This week we will look at function pointers, function objects (functors) and lambda expressions. We will also look at handling exceptions. 
  During the lab portion, we will look at linked lists and source code for a stack class and a queue class in preparation for 
assignment 2.</p>

<h3>Videos</h3>
<table>
  <tr><td>Lecture Recording</td><td><a href="https://seneca.sharepoint.com/sites/SEP200Object-OrientedProgramming/Shared%20Documents/General/Recordings/View%20Only/SEP200%20Object-Oriented%20Programming%20-%20Lecture-20220322_085815-Meeting%20Recording.mp4?web=1" target="_blank">March 22 (mp4)</a></td></tr>
  <tr><td>Lab Recording</td><td><a href="https://seneca.sharepoint.com/sites/SEP200Object-OrientedProgramming/Shared%20Documents/General/Recordings/View%20Only/SEP200%20Object-Oriented%20Programming%20-%20Lab-20220325_080444-Meeting%20Recording.mp4?web=1" target="_blank">March 25 (mp4)</a></td></tr>
  <tr><td>Function Pointers</td><td><a href="https://www.youtube.com/watch?v=p4sDgQ-jao4" target="_blank">Function Pointers in C++</a></td></tr>
  <tr><td>Functors</td><td><a href="https://www.youtube.com/watch?v=alX0OtgLeFM" target="_blank">Functor In C++</a></td></tr>
  <tr><td>Lambda Expressions</td><td><a href="https://www.youtube.com/watch?v=tSFxYZTh43g" target="_blank">C++ Lambda Expressions and Functions Tutorial</a></td></tr>
  <tr><td>Exception Handling</td><td><a href="https://www.youtube.com/watch?v=mFAaqmj399I" target="_blank">Buckys C++ Programming Tutorials - 62 - Exceptions</a></td></tr>
  <tr><td>Linked Lists</td><td><a href="https://www.youtube.com/watch?v=o5wJkJJpKtM" target="_blank">How to Create a Linked List C++ Introduction to Linked Lists</a></td></tr>
</table>

<h3>Quiz</h3>
<p>.</p>

<h3>Lecture Material</h3>
<ul>
  <li>Chapters 7, 11 to 13 and 31 of <a href="https://senecacollege.primo.exlibrisgroup.com/permalink/01SENC_INST/iq0dqm/alma997259304203226" target="_blank">The C++ Programming Language</a></li>
  <li>Chapters 3, 6, 14 and 18 of <a href="https://senecacollege.primo.exlibrisgroup.com/permalink/01SENC_INST/1g8f6u9/cdi_safari_books_9780133053043" target="_blank">C++ Primer</a></li>
  <li><a href="FunctionsAdvanced.docx" target="_blank">Functions (Advanced)</a></li>
  <li><a href="ErrorHandling.docx" target="_blank">Exceptions</a></li>
  <li><a href="LinkedLists.docx" target="_blank">Linked Lists</a></li>
</ul>

<h3>Lab(s)</h3>
<ul>
  <li><a href="../Labs/Lab7/Lab7.html" target="_blank">Lab 7</a>.</li>
  <li><a href="../Labs/Lab8/Lab8.html" target="_blank">Lab 8</a>.</li>
</ul>

<h3>Assignment(s)</h3>
<ul>
  <li><a href="../Assignments/Assignment1/Assignment1.html" target="_blank">Assignment 1</a>.</li>
  <li><a href="../Assignments/Assignment2/Assignment2.html" target="_blank">Assignment 2</a>.</li>
</ul>

<h3>Sample Code</h3>

<p><em>Class Enumerator</em></p>
<p>It is good to associate certain enumerations with a certain class, therefore we have class enumerations. A simple example with
   a class enumerator can be seen at:<br>
<a href="enumClass/enumClass.cpp" target="_blank">enumClass.cpp</a>.
</p>

<p><em>Recursion</em></p>
<p>Recursion occurs when a function calls itself. This may seem a little silly, but is in fact very useful when implementing binary trees. 
  A recursive function has two parts - the recursive part, and the base case. As a function calls itself repeatedly, it eventually finds itself
  at the base case, in which case the recursion unwinds.</p>
<p>Many mathematical operations lend themselves to recursive programming. For instance, consider the factorial operation. This consists of 
    a series of multiplications as follows:<br>
    <b>n! = n*(n-1)*(n-2)*(n-3) ... *2*1</b><br>
    This could be rewritten as:<br>
    <b>n! = n*(n-1)!</b><br>
    In C++, this is written as follows:
    <pre>
    int factorial(int n) {
      if(n>1) return n * factorial(n-1);
      else    return 1;
    }
  </pre>
  An example of using recursion to calculate the factorial of a number can be found at:<br>
<a href="Factorial/Factorial.cpp" target="_blank">Factorial.cpp</a>.
</p>

<p><em>A Function Pointer</em></p>
<p>A function pointer is very useful for threads and for interrupt-programming. One of the parameters in thread creation is a pointer 
  to a function that will run as a thread. For instance, if you want to create a read thread for reading data packets from a network,
  you could create a function <b>ReadThread</b> and then invoke it on thread creation. Likewise, you might assign a callback function that 
  needs to be run in case your program receives a signal from the operating system or an interrupt on a hardware pin. Your program will 
  have a pointer to this callback function, which will be invoked on interrupt. JavaScript has the concept of a callback function which 
  is invoked if, for instance, a button is clicked on your mouse.</p>
  <p>Functions do exist in memory as binaries, and we can use a pointer to point to the beginning of a function in the same way we can 
  use a pointer to point to an object or variable in memory. An example of using a function pointer can be seen at:<br>
<a href="FunctionPointer/ReportMarks.cpp" target="_blank">ReportMarks.cpp</a>.<br>
Function pointers can also appear as an array of functions. The function pointer points to one of the functions in its array depending
on the array index. An example of using an array of function pointers can be seen at<br>
<a href="FunctionPointer2/ReportMarks2.cpp" target="_blank">ReportMarks2.cpp</a>.<br></br>
There is something in C++ called a virtual table. It will point to the correct function 
in a polymorphic arrangement. The C++ compiler uses a function pointer within itself to 
resolve which function should be called, ie Base::PrintInfo() or Derived::PrintInfo():
<pre>
class Base {
    virtual void PrintInfo();
};
class Derived:public Base {
    void PrintInfo();
};
</pre>
</p>

<p><em>Functor</em></p>
<p>A functor is basically a class that presents a function-like interface to the calling program. Functors have certain advantages over 
  functions. Unlike functions, functors can have state. They fit into the object-oriented paradigm as compared to functions because functors 
  are actually based on classes. Functors are often inlined by the compiler, unlike function pointers. The functor does not require runtime 
  dispatching, therefore it is more efficient in most cases. The following functor provides two types of multiplication:<br>
<a href="MultiplierFunctor/MultiplierFunctor.cpp" target="_blank">MultiplierFunctor.cpp</a>.
</p>

<p><em>Lambda Functions</em></p>
<p>Lambda functions are anonymous functions which provide a function-like interface similar to functors. Lambda functions are not 
  based on a class. Lambda functions are used extensively with the Standard Template Library as inline functions. The following example 
  demonstrates a lambda function used with remove_if() to determine which elements of an array should be removed:<br>
<a href="LambdaSelect/LambdaSelect.cpp" target="_blank">LambdaSelect.cpp</a>.</p>
<p>Lambda functions can also be standalone within another function. The following example uses a lambda function to calculate the average 
height of basketball and hockey players:<br>
<a href="Average/Average.cpp" target="_blank">Average.cpp</a>.</p>
</p>

<p><em>Exceptions</em></p>
<p>An exception is a form of software interrupt. They occur when something unusual happens, such as a divide-by-zero, trying to access 
  an array outside of the array bounds, trying to allocate memory when there is no longer any available RAM, etc... What you may 
  not know is that you can intercept this software interrupt in your code using exceptions. You can generate interrupts as well 
  when you detect an unusual situation in your code. The following code generates exceptions for an array out of bounds error 
  as well as a divide-by-zero error:<br>
<a href="Exception/Exception.cpp" target="_blank">Exception.cpp</a>.
</p>

<p><em>Linked Lists</em></p>
<p>
A simple linked list is shown in the code: 
  <a href="LinkedList/LinkedList.cpp" target="_blank">LinkedList.cpp</a>.<br>
  A queue and stack can be implemented from a linked list. A custom queue is shown in the code:
  <a href="Queue/Queue.cpp" target="_blank">Queue.cpp</a>.<br>
  A custom stack is shown in the code:
   <a href="Stack/Stack.cpp" target="_blank">Stack.cpp</a>.<br>
</p>

<p><em>A Doubly Linked List for Student Information</em></p>
<p>We looked at source code for a stack and for a queue in C++. The following is partially implemented code for a doubly linked list 
  based on a Student structure. The student list can get the next/previous node, push a student to the back of the list, get the 
  student from the back of the list pop the student off the back of the list, and print the entire list. A destructor deletes 
  any students remaining in the list on program exit. An iterator class has been added inside the student list class, to show 
  how iterators can interact with the nodes of this class. The program can be seen at:<br>
  <a href="DoublyLinkedList/StudentList.h" target="_blank">StudentList.h</a>, 
  <a href="DoublyLinkedList/StudentList.cpp" target="_blank">StudentList.cpp</a> and 
  <a href="DoublyLinkedList/StudentListMain.cpp" target="_blank">StudentListMain.cpp</a>.</p>