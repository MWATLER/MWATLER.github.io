<h2>SEP400 - Lab 8: RSA Encryption/Decryption</h2>

<h3>Due: Friday, March 31, 2023</h3>

<p>Two processes are going to communicate with each other via UDP INET sockets. The data being passed back and forth will be 
    encrypted using RSA encryption. We will assume that authentication has taken place and that they will use the same private 
    key for encryption, and the same private key for decryption. The two prime numbers used in the scheme are:<br>
    <b>p=11, q=23</b>.<br>
    From these two prime numbers the remaining parameters for RSA (<b>n, phi, e, and d</b>) can be determined.
</p>
<p>For RSA encryption,
<ul>
    <li>select two large prime numbers <b>p</b> and <b>q</b>,</li>
    <li><b>n=p*q</b>,</li>
    <li><b>phi=(p-1)(q-1)</b>,</li>
    <li><b>e</b> is co-prime with <b>phi</b> without being bigger than <b>phi</b> <b>(gcd(e,phi)=1)</b>, and</li>
    <li>calculate the modular inverse <b>d</b> of <b>e mod (phi)</b> such that <b>d * e = 1 mod(phi)</b>. This could be rewritten as<br>
        <b>d*e = 1 + k * phi</b> where <b>k</b> is a constant,<br>
        <b>d=(1+k*phi)/e</b>. If <b>d</b> is not an integer, choose another value for <b>k</b>.</li>
    <li>Encryption is performed as follows: <b>c=m<sup>e</sup>mod(n)</b>, where <b>m</b> is the message and <b>c</b> is the ciphertext.</li>
    <li>Decryption is performed as follows: <b>m=c<sup>d</sup>mod(n)</b>, where <b>c</b> is the ciphertext and <b>m</b> is the message.</li>
</ul>
</p>

<p>Client 1 is going to pass the following 5 messages to client 2:<br>
    <i>"House? You were lucky to have a house!",<br>
	"We used to live in one room, all hundred and twenty-six of us, no furniture.",<br>
	"Half the floor was missing;",<br>
	"we were all huddled together in one corner for fear of falling.",<br>
    "Quit"</i><br><br>
Client 2 is going to pass the following 5 messages to client 1:<br>
    <i>"You were lucky to have a room. We used to have to live in a corridor.",<br>
    "Oh we used to dream of livin' in a corridor! Woulda' been a palace to us.",<br>
    "We used to live in an old water tank on a rubbish tip.",<br>
    "We got woken up every morning by having a load of rotting fish dumped all over us.",<br>
    "Quit"</i><br><br>
</p>

<p>The code for your clients will almost be identical. They can both run on the same machine.
<ul>
    <li>Client 1 will bind to 127.0.0.1:PORT_1 and client 2 can bind to 127.0.0.1:PORT_2. They know each other's ports.</li>
    <li>Each client should encrypt and send in one thread (could be the main function), and receive and decrypt in another thread.</li>
    <li>Received messages which have been decrypted should be put in a message queue and displayed at the top of the send thread</li>
    <li>Ensure shared resources are protected with mutex'es.</li>
    <li>Note that your ciphertext might not fit into the dataspace of a char. You might have to use a double instead. This means you might 
        be sending and receiving an array of double's in your send and receive threads.</li>
    <li>There should be a 5 second delay before a client starts sending data.</li>
    <li>There should be a 1 second delay between sending each of the 5 messages.</li>
    <li>When "Quit" is received in the receive thread, the client should shut down gracefully.</li>
</ul>
</p>

<p>The Makefile as well as skeleton code has been given for the clients. Feel free to change any of these if you wish:<br>
    <a href="Makefile" target="_blank">Makefile</a>,
    <a href="client1.cpp" target="_blank">client1.cpp</a> and
    <a href="client2.cpp" target="_blank">client2.cpp</a>.
</p>

<p>Be sure to start both processes simultaneously. A sample run is shown below. For client 1:<br>
<pre>
    miguelwatler@ubuntu:~/sep400/Labs/Lab8$ ./client1
    p:11 q:23 n:253 phi:220 e:3 d:147
    Received: You were lucky to have a room. We used to have to live in a corridor.
    Received: Oh we used to dream of livin' in a corridor! Woulda' been a palace to us.
    Received: We used to live in an old water tank on a rubbish tip.
    Received: We got woken up every morning by having a load of rotting fish dumped all over us.
    client1 is quitting...
    miguelwatler@ubuntu:~/sep400/Labs/Lab8$
</pre>
For client 2:<br>
<pre>
    miguelwatler@ubuntu:~/sep400/Labs/Lab8$ ./client2
    p:11 q:23 n:253 phi:220 e:3 d:147
    Received: House? You were lucky to have a house!
    Received: We used to live in one room, all hundred and twenty-six of us, no furniture.
    Received: Half the floor was missing;
    Received: we were all huddled together in one corner for fear of falling.
    client2 is quitting...
    miguelwatler@ubuntu:~/sep400/Labs/Lab8$   
</pre>
</p>

<u>Questions</u>
<ol>
    <li>What happens if your modulus <b>n</b> is too small, keeping in mind the range of the ASCII values for alpha-numeric characters?</li>
    <li>With quantum computers, will it be easy to crack the RSA algorithm? Why?</li>
    <li>For very large values of <b>p</b> and <b>q</b> and the large data spaces involved, is it reasonable to perform all parts of RSA 
    encryption in software? What parts might you consider implementing in hardware? To answer this, you might wish to look at the abstract of the 
    following paper: <a href="https://ieeexplore.ieee.org/document/5276895" target="_blank">Efficient hardware implementation of RSA cryptography</a>.</li>
</ol>

<h3>Lab Submission:</h3>

<p>Please mail your <b>Makefile</b>, <b>client1.cpp</b> and <b>client2.cpp</b> to:
   <a href="mailto: miguel.watler@senecacollege.ca">miguel.watler@senecacollege.ca</a></p>
        
<p><b>NB: My last name is Watler, not Walter.</b></p>
    
