<h1>Week 3 - Inheritance and Inclusion Polymorphism, more Templates</h1>

<h3>Introduction</h3>
<p>This week we will look at some corner cases with inheritance. We will also look at the Liskov Substitution Principle. 
  We will look at templates again, particularly parametric polymorphism.</p>

<h3>Videos</h3>
<table>
  <tr><td>Liskov's Substitution Principle</td><td><a href="https://www.youtube.com/watch?v=bVwZquRH1Vk" target="_blank">Liskov Substitution Principle (SOLID), The Robustness Principle, and DbC</a></td></tr>
  <tr><td>The clone() function</td><td><a href="https://www.youtube.com/watch?v=UHP-DKrxgBs&list=PLE28375D4AC946CC3&index=15" target="_blank">Advanced C++: Virtual Constructor - Clone() Function</a></td></tr>
  <tr><td>Parametric Polymorphism</td><td><a href="https://www.youtube.com/watch?v=-WV9vWjhI3g&t=258s" target="_blank">Advanced C++: Static Polymorphism</a></td></tr>
</table>

<h3>Sample Code</h3>

<p><em>Geometric Shape, Geometric Shape 2</em></p>
<p>Code that demonstrates the <b>clone()</b> function can be seen in the code below. Note that the second object 
  is created from the first, but is in fact a separate object:
<ul>
  <li>
    <a href="GeometricShape/Shape.h" target="_blank">Shape.h</a>,
    <a href="GeometricShape/Cube.h" target="_blank">Cube.h</a>,
    <a href="GeometricShape/Cube.cpp" target="_blank">Cube.cpp</a>,
    <a href="GeometricShape/Sphere.h" target="_blank">Sphere.h</a>,
    <a href="GeometricShape/Sphere.cpp" target="_blank">Sphere.cpp</a> and
    <a href="GeometricShape/CloningMain.cpp" target="_blank">CloningMain.cpp</a>.
  </li>
</ul>
The second program uses the same classes but demonstrates dynamic binding in a comparison function:
<ul>
  <li>
    <a href="GeometricShape2/Shape.h" target="_blank">Shape.h</a>,
    <a href="GeometricShape2/Cube.h" target="_blank">Cube.h</a>,
    <a href="GeometricShape2/Cube.cpp" target="_blank">Cube.cpp</a>,
    <a href="GeometricShape2/Sphere.h" target="_blank">Sphere.h</a>,
    <a href="GeometricShape2/Sphere.cpp" target="_blank">Sphere.cpp</a> and
    <a href="GeometricShape2/CloningMain.cpp" target="_blank">CloningMain.cpp</a>.
  </li>
</ul>
</p>

<p><em>Dynamic Type</em></p>
<p>This next example uses <b>typeid</b> to identify a dynamic type. The program wishes to exclude an object of a 
  particular derived type:
<ul>
  <li>
    <a href="DynamicType/DynamicType.cpp" target="_blank">DynamicType.cpp</a>.
  </li>
</ul></p>

<p><em>Parameter Adder</em></p>
<p>This example uses variadic templates to add the values of all its parameters:
<ul>
  <li>
    <a href="ParameterAdder/ParameterAdder.cpp" target="_blank">ParameterAdder.cpp</a>.
  </li>
</ul></p>

<p><em>MathTest</em></p>
<p>The first program is simply a refresher on the use of templates. Here the functions perform a square on any type, 
  presented as a number, or as a fraction:
<ul>
  <li>
    <a href="MathTest/Math.h" target="_blank">Math.h</a> and
    <a href="MathTest/MathTest.cpp" target="_blank">MathTest.cpp</a>.
  </li>
</ul>

<p><em>Math Test with Polymorphism</em></p>
<p>A second MathTest program has been created to show how to implement inheritance with templates. This math library performs calculation on a series of 
  numbers. The calculations are to add the series, or to multiply the series. The numbers could be of any numerical type. The base class exposes one 
  virtual function: Calculate(). There is a MathAdd derived class for adding a series of numbers and there is a MathMultiply 
  function for multiplying a series of numbers. Templated are the type of numbers to be operated on, as well as the length of the series itself.<br>
  The code is as follows:
    <a href="MathTest2/MathTest2.h" target="_blank">MathTest2.h</a> and
    <a href="MathTest2/MathTest2.cpp" target="_blank">MathTest2.cpp</a>.</p>

<p><em>Math Test with Parametric Polymorphism</em></p>
<p>A third MathTest program has been created to show how to implement parametric polymorphism with templates. This math library also performs calculation 
  on a series of numbers. As with MathTest2, the calculations are to add the series (a MathAdd object), or to multiply the series (a MathMultiply object). 
  The numbers to be added or multiplied could be of any numerical type. The common header file exposes the function Calculate() which takes as its first 
  argument a math library object which could be of any type (in this case either MathAdd or MathMultiply), an array of numbers as its second argument,
  and the array length as its third argument. Calculate determines which math object to access based on the type of its first argument. This requires 
  both the MathAdd and MathMultiply objects to expose the same function, in this case Calculate().<br>
  The code is as follows:
    <a href="MathTest3/MathCommon.h" target="_blank">MathCommon.h</a>,
    <a href="MathTest3/MathAdd.h" target="_blank">MathAdd.h</a>,
    <a href="MathTest3/MathMultiply.h" target="_blank">MathMultiply.h</a>, and
    <a href="MathTest3/MathTest3.cpp" target="_blank">MathTest3.cpp</a>.</p>

    <p><em>Stooge Factory</em></p>
<p>The Stooge factory is an example of the factory design pattern, which can create a set of related objects through a static <b>make_stooge()</b> function. 
  The program is based on the popular comedy "The Three Stooges". The factory can create three stooges: Larry, Curly and Moe. They are tied together 
  through a common base class. StoogeMain.cpp allows you to create whichever stooge you wish, up to three of them, via dynamic binding:
<ul>
  <li>
    <a href="StoogeFactory/Stooge.h" target="_blank">Stooge.h</a>,
    <a href="StoogeFactory/Stooge.cpp" target="_blank">Stooge.cpp</a>,
    <a href="StoogeFactory/Curly.h" target="_blank">Curly.h</a>,
    <a href="StoogeFactory/Larry.h" target="_blank">Larry.h</a>,
    <a href="StoogeFactory/Moe.h" target="_blank">Moe.h</a> and
    <a href="StoogeFactory/StoogeMain.cpp" target="_blank">StoogeMain.cpp</a>.
  </li>
</ul>
</p>
