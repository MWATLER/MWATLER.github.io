<h1>Week 4 - Composition and Expressions</h1>

<h3>Introduction</h3>
<p>This week we will look at composition, aggregation and association, and also advanced C++ expressions. The composition represents the 
  <b>has-a</b> relationship, in contrast to inheritance which is an <b>is-a</b> relationship.</p>

<h3>Videos</h3>
<table>
  <tr><td>Composition, Aggregations and Associations</td><td><a href="https://www.youtube.com/watch?v=URE9MCTF8Ls" target="_blank">Association Aggregation and Composition</a></td></tr>
  <tr><td>Casts</td><td><a href="https://www.youtube.com/watch?v=lglGKxNrLgM" target="_blank">Advanced C++: All Castings Considered - Part I</a></td></tr>
  <tr><td></td><td><a href="https://www.youtube.com/watch?v=UfrR1nNfoeY" target="_blank">Advanced C++: All Castings Considered - Part II</a></td></tr>
  <tr><td>Exception Handling</td><td><a href="https://www.youtube.com/watch?v=mFAaqmj399I" target="_blank">Buckys C++ Programming Tutorials - 62 - Exceptions</a></td></tr>
  <tr><td>Bitwise Operators</td><td><a href="https://www.youtube.com/watch?v=hlvAojWf-eU" target="_blank">C++ Programming Tutorial 18 - Bitwise Operators</a></td></tr>
</table>

<h3>Reference Material</h3>
<ul>
  <li>Cplusplus.com <a href="https://www.cplusplus.com/doc/tutorial/typecasting/" target="_blank">Type conversions</a></li>
</ul>

<h3>Sample Code</h3>

<p><em>Composition</em></p>
<p>It is possible for a class to contain an instance of another class (composition), a collection of instances of another class (aggregation), or an instance of another class which in turn 
  contains an instance of the class itself (association). We will look at three examples, one of each type.</p>
<ul>
<li>
  In the first example, the class Person contains an instance of the class Name. This is <b>composition</b>:<br>
  <a href="Composition/Name.h" target="_blank">Name.h</a>,
  <a href="Composition/Name.cpp" target="_blank">Name.cpp</a>,
  <a href="Composition/Person.h" target="_blank">Person.h</a>,
  <a href="Composition/Person.cpp" target="_blank">Person.cpp</a> and
  <a href="Composition/CompositionMain.cpp" target="_blank">CompositionMain.cpp</a>. 
</li>

<li>
  In the second example, a Course contains a Room, and a Room contains a Course. The room and course are associated with each other. 
  This is <b>association</b>. The course and room each contain a name as well:<br>
  <a href="Association/Name.h" target="_blank">Name.h</a>,
  <a href="Association/Name.cpp" target="_blank">Name.cpp</a>,
  <a href="Association/Course.h" target="_blank">Course.h</a>,
  <a href="Association/Course.cpp" target="_blank">Course.cpp</a>,
  <a href="Association/Room.h" target="_blank">Room.h</a>,
  <a href="Association/Room.cpp" target="_blank">Room.cpp</a> and
  <a href="Association/AssociationMain.cpp" target="_blank">AssociationMain.cpp</a>.
</li>

<li>
  In the third example, the class Club contains an array of pointers to Names which have been created outside of the class. 
  This is <b>aggregation</b>:<br>
  <a href="Aggregation/Name.h" target="_blank">Name.h</a>,
  <a href="Aggregation/Name.cpp" target="_blank">Name.cpp</a>,
  <a href="Aggregation/Club.h" target="_blank">Club.h</a>,
  <a href="Aggregation/Club.cpp" target="_blank">Club.cpp</a> and
  <a href="Aggregation/AggregationMain.cpp" target="_blank">AggregationMain.cpp</a>.
</li>
<li>The third example above used an array of pointers where the size of the array is known. What if the size of the array is not known? We 
  will have to use a <b>double pointer</b>! The <b>double pointer</b> is illustrated in the document 
  <a href="Aggregation2/DoublePointer.rtf" target="_blank">DoublePointer.rtf</a>. 
  See the following code that allocates and de-allocates the array of pointers in batches of five:<br>
  <a href="Aggregation2/Name.h" target="_blank">Name.h</a>,
  <a href="Aggregation2/Name.cpp" target="_blank">Name.cpp</a>,
  <a href="Aggregation2/Club.h" target="_blank">Club.h</a>,
  <a href="Aggregation2/Club.cpp" target="_blank">Club.cpp</a> and
  <a href="Aggregation2/AggregationMain.cpp" target="_blank">AggregationMain.cpp</a>.
</li>
<li>It is possible to have an aggregation of different types if these types are related. The following example shows an aggregation of different types 
  which are related through a base class. The types are <b>Hammer</b> and <b>Screwdriver</b>. They are both tools and are derived from a <b>ToolIf</b> 
  interface class:<br>
  <a href="Toolbox/ToolIf.h" target="_blank">ToolIf.h</a>,
  <a href="Toolbox/ToolIf.cpp" target="_blank">ToolIf.cpp</a>,
  <a href="Toolbox/Hammer.h" target="_blank">Hammer.h</a>,
  <a href="Toolbox/Screwdriver.h" target="_blank">Screwdriver.h</a>,
  <a href="Toolbox/Toolbox.h" target="_blank">Toolbox.h</a> and
  <a href="Toolbox/ToolMain.cpp" target="_blank">ToolMain.cpp</a>.<br>
  A sample run is shown in <a href="Toolbox/SampleRun.txt" target="_blank">SampleRun.txt</a>.
</li>

</ul>

<p><em>Casts</em></p>
<p>C++ introduces four types of casts.
  <ul>
    <li><b>const_cast</b> can be used to remove or add const to a variable. This can be useful if it is necessary to add/remove constness from a variable.</li>
    <li><b>static_cast</b> is used for the normal/ordinary type conversion. This is also the cast responsible for implicit type coersion
      and can also be called explicitly. You should use it in cases like converting float to int, char to int, etc.</li>
    <li><b>dynamic_cast</b> is used for handling polymorphism. You only need to use it when you're casting to a derived class. This is exclusively to 
      be used in inheritence when you cast from base class to derived class.</li>
    <li><b>reinterpret_cast</b> is the trickiest to use. It is used for reinterpreting bit patterns and is extremely low level. It's used primarily for
      things like turning a raw data bit stream into actual data or storing data in the low bits of an aligned pointer.</li>
</ul>
Code that demonstrates each can be found at:
<ul>
  <li>
    <a href="Cast/Cast.cpp" target="_blank">Cast.cpp</a>,
    <a href="ConstCast/ConstCast.cpp" target="_blank">ConstCast.cpp</a>,
    <a href="StaticCast/StaticCast.cpp" target="_blank">StaticCast.cpp</a>,
    <a href="DynamicCast/DynamicCast.cpp" target="_blank">DynamicCast.cpp</a> and
    <a href="ReinterpretCast/ReinterpretCast.cpp" target="_blank">ReinterpretCast.cpp</a>.
  </li>
</ul>
</p>

<p><em>Exceptions</em></p>
<p>An exception is a form of software interrupt. They occur when something unusual happens, such as a divide-by-zero, trying to access 
  an array outside of the array bounds, trying to allocate memory when there is no longer any available RAM, etc... What you may 
  not know is that you can intercept this software interrupt in your code using exceptions. You can generate interrupts as well 
  when you detect an unusual situation in your code. The following code generates exceptions for an array out of bounds error 
  as well as a divide-by-zero error:<br>
<a href="Exception/Exception.cpp" target="_blank">Exception.cpp</a>.
</p>

<p><em>Masks</em></p>
<p>C++ masks are used for enabling or disabling features for an object such as a file. Since enable/disable is a binary operation, each feature 
  can be stored in one bit. All features together in one variable is called a <b>mask</b>. Generally speaking, a bit mask allows us to store 
  multiple related values in one variable. A document that shows how to set and unset a bit in a bit mask can be seen at
  <a href="SetUnsetBit/SetUnsetBit.docx" target="_blank">SetUnsetBit.docx</a>. For an example on the use of bit-masks, see:
<ul>
  <li>
    <a href="SetUnsetBit/Sample.txt" target="_blank">Sample.txt</a> and
    <a href="SetUnsetBit/FileOperations.h" target="_blank">FileOperations.h</a> and
    <a href="SetUnsetBit/SetUnsetBit.cpp" target="_blank">SetUnsetBit.cpp</a>.
  </li>
</ul>
</p>

<p><em>Templated Database (sample code for workshop 3)</em></p>
<p>Sample code for workshop 3 templates a database which contains up to 20 key-value entries. The entries are initially read from a file. 
  Before database destruction, whatever entries are contained within the database are written back to the file. The example demonstates a 
  <b>GetValue()</b> function for retrieving a value given a key, and also a <b>SetValue()</b> function which creates and stores a key-value pair. 
  The database also overloads <b>operator+=</b>, where a second class is introduced, called <b>KeyValue</b>. This class only contains a
  key-value pair with getter functions to get the key and get the value. Three objects of type <b>KeyValue</b> are created in the main 
  function and added to the database via <b>operator+=</b>. The sample code is as follows:
  <ul>
    <li>
      <a href="DatabaseT/Data.txt" target="_blank">Data.txt</a>,
      <a href="DatabaseT/Data2.txt" target="_blank">Data2.txt</a>,
      <a href="DatabaseT/Database.h" target="_blank">Database.h</a>,
      <a href="DatabaseT/KeyValue.h" target="_blank">KeyValue.h</a> and
      <a href="DatabaseT/DatabaseMain.cpp" target="_blank">DatabaseMain.cpp</a>.
    </li>
  </ul>
  A second example has been created where the database relies entirely on the <b>KeyValue</b> object for all its key-value pairs. Some 
  objects of type <b>KeyValue</b> are created within the database, for instance when reading the initial values from a file, and some 
  objects of type <b>KeyValue</b> are created in the main function and passed through by reference. This is not true aggregation, 
  in that the destructor now does not know which objects of type <b>KeyValue</b> it should destroy. Normally it would destroy all 
  objects created by the database. The code is seen as follows:
  <ul>
    <li>
      <a href="DatabaseT2/Data.txt" target="_blank">Data.txt</a>,
      <a href="DatabaseT2/Data2.txt" target="_blank">Data2.txt</a>,
      <a href="DatabaseT2/Database.h" target="_blank">Database.h</a>,
      <a href="DatabaseT2/KeyValue.h" target="_blank">KeyValue.h</a> and
      <a href="DatabaseT2/DatabaseMain.cpp" target="_blank">DatabaseMain.cpp</a>.
    </li>
  </ul>
</p>
